<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a3a">
    <meta name="description" content="IQ Pentagon - Puzzle de lÃ³gica con 120 retos">
    <title>IQ Pentagon</title>
    
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-96.png">
    
    <!-- Font with offline fallback -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Orbitron-Fallback';
            src: local('Arial Black'), local('Arial Bold'), local('sans-serif-black');
            font-weight: 700;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            height: 100%; 
            overflow: auto; 
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        body {
            font-family: 'Orbitron', 'Orbitron-Fallback', 'Arial Black', sans-serif;
            background: linear-gradient(180deg, #f0f0f5 0%, #ffffff 50%, #f0f0f5 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100dvh;
            padding: 10px;
            gap: 8px;
        }
        .title {
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 4px;
            color: #4a4a6a;
        }
        #game-svg {
            width: min(95vw, 550px);
            height: auto;
        }
        #game-controls {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #3a3a5a;
            gap: 6px;
        }
        #game-controls .btn {
            padding: 6px 12px;
            font-size: 0.85rem;
            min-width: 40px;
        }
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .btn {
            background: linear-gradient(145deg, #2a2a4a, #1a1a3a);
            border: 1px solid #3a3a5a;
            color: #c0c0ff;
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 5px rgba(192,192,255,0.3);
        }
        .btn:hover {
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            color: #e0e0ff;
            text-shadow: 0 0 8px rgba(224,224,255,0.5);
        }
        .btn:active {
            transform: scale(0.95);
        }
        .btn.active {
            background: linear-gradient(145deg, #3a6a3a, #2a5a2a);
            color: #88ff88;
            border-color: #4a8a4a;
        }
        .btn.completed {
            background: linear-gradient(145deg, #2a6a4a, #1a5a3a);
            color: #88ffaa;
            border-color: #4a9a6a;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(136,255,170,0.5);
        }
        .btn.cat-starter { background: linear-gradient(145deg, #40a040, #208020); color: #ccffcc; border-color: #60c060; text-shadow: 0 0 5px rgba(100,255,100,0.5); }
        .btn.cat-junior { background: linear-gradient(145deg, #c0c020, #a0a000); color: #ffffcc; border-color: #e0e040; text-shadow: 0 0 5px rgba(255,255,100,0.5); }
        .btn.cat-expert { background: linear-gradient(145deg, #e08020, #c06000); color: #ffeecc; border-color: #ffa040; text-shadow: 0 0 5px rgba(255,180,100,0.5); }
        .btn.cat-master { background: linear-gradient(145deg, #d03030, #a01010); color: #ffcccc; border-color: #f05050; text-shadow: 0 0 5px rgba(255,100,100,0.5); }
        .btn.cat-wizard { background: linear-gradient(145deg, #9030d0, #6010a0); color: #eeccff; border-color: #b050f0; text-shadow: 0 0 5px rgba(200,100,255,0.5); }
        .btn.cat-starter.active, .btn.cat-junior.active, .btn.cat-expert.active, .btn.cat-master.active, .btn.cat-wizard.active {
            box-shadow: 0 0 15px currentColor;
            transform: scale(1.05);
        }
        .hidden { display: none !important; }
        #challenge-grid-container {
            transition: all 0.3s ease;
        }
        #category-selector {
            flex-wrap: wrap;
        }
        #category-selector .btn {
            font-size: 0.6rem;
            padding: 6px 10px;
        }
        #category-selector .btn span {
            font-size: 0.5rem;
            opacity: 0.8;
        }
        #category-selector .btn.level-selected {
            box-shadow: 0 0 0 3px #1a1a3a, 0 0 8px rgba(0,0,0,0.5);
            transform: scale(1.05);
        }
        #toggle-grid-btn {
            font-size: 0.8rem !important;
            min-width: 35px;
        }
        .victory-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; gap: 20px; z-index: 1000;
        }
        .victory-overlay.hidden { display: none; }
        .victory-text { font-size: 2rem; color: #88ff88; text-shadow: 0 0 20px rgba(136,255,136,0.8); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 1001;
            animation: confetti-fall 3s ease-out forwards;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .game-status {
            font-size: 1rem;
            color: #aaccff;
            text-shadow: 0 0 8px rgba(170,204,255,0.5);
            font-weight: 700;
            margin-bottom: 5px;
        }
        .info {
            font-size: 0.7rem;
            color: #aaaacc;
            text-align: center;
        }
        .ficha-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 900;
            fill: #0000ff;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        /* Help Modal */
        .help-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 15px;
        }
        .help-overlay.hidden { display: none; }
        .help-content {
            background: linear-gradient(145deg, #1a1a2e, #0f0f1a);
            border: 2px solid #3a3a5a;
            border-radius: 15px;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            padding: 20px;
            color: #c0c0e0;
            font-family: 'Orbitron', sans-serif;
        }
        .help-content h2 {
            color: #88aaff;
            font-size: 1.2rem;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #3a3a5a;
            padding-bottom: 10px;
        }
        .help-content h3 {
            color: #aaccff;
            font-size: 0.85rem;
            margin: 15px 0 8px 0;
        }
        .help-content p {
            font-size: 0.75rem;
            line-height: 1.5;
            margin-bottom: 10px;
            color: #a0a0c0;
        }
        .help-content .help-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.75rem;
        }
        .help-content .help-icon {
            background: linear-gradient(145deg, #2a2a4a, #1a1a3a);
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            padding: 4px 8px;
            min-width: 35px;
            text-align: center;
            font-size: 0.85rem;
        }
        .help-content .close-help {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
        }
        .help-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #fff;
            border-radius: 50%;
            position: relative;
            vertical-align: middle;
        }
        .help-indicator::after {
            content: '';
            position: absolute;
            width: 5px;
            height: 5px;
            background: #fff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div style="display: flex; align-items: center; gap: 15px;">
        <h1 class="title">IQ PENTAGON</h1>
        <button class="btn" onclick="showHelp()" style="padding: 4px 10px; font-size: 0.8rem;">?</button>
    </div>
    <p id="game-info" class="game-status">Selecciona categorÃ­a y reto</p>
    
    <!-- Help Modal -->
    <div id="help-overlay" class="help-overlay hidden" onclick="if(event.target === this) hideHelp()">
        <div class="help-content">
            <h2>ðŸ“– CÃ³mo Jugar</h2>
            
            <h3>ðŸŽ¯ Objetivo</h3>
            <p>Coloca todas las piezas del puzzle en el tablero. Solo hay una soluciÃ³n para cada reto.</p>
            
            <h3>ðŸ“‹ Reglas</h3>
            <p><strong>1.</strong> Selecciona un nivel de dificultad y un reto.</p>
            <p><strong>2.</strong> Coloca las piezas restantes en el tablero. Las piezas son de doble cara y pueden voltearse.</p>
            <p><strong>3.</strong> Cada reto tiene una Ãºnica soluciÃ³n.</p>
            
            <h3>ðŸŽ® Controles</h3>
            <div class="help-item">
                <span class="help-icon">âŸ³</span>
                <span>Rotar la pieza seleccionada (72Â°)</span>
            </div>
            <div class="help-item">
                <span class="help-icon">â†”H</span>
                <span>Voltear horizontalmente</span>
            </div>
            <div class="help-item">
                <span class="help-icon">â†•V</span>
                <span>Voltear verticalmente</span>
            </div>
            <div class="help-item">
                <span class="help-icon">ðŸ”„</span>
                <span>Reiniciar el reto actual</span>
            </div>
            <div class="help-item">
                <span class="help-icon">ðŸ’¡</span>
                <span>Obtener una pista (coloca una pieza)</span>
            </div>
            
            <h3>ðŸ§© Las Piezas</h3>
            <p>Las piezas con el indicador <span class="help-indicator"></span> son mÃ³viles y puedes arrastrarlas al tablero.</p>
            <p>Las piezas sin indicador estÃ¡n fijas como parte del reto inicial.</p>
            
            <h3>ðŸ“Š Niveles</h3>
            <p><strong>STARTER / JUNIOR:</strong> MÃ¡s piezas colocadas, mÃ¡s fÃ¡cil.</p>
            <p><strong>EXPERT:</strong> Dificultad media.</p>
            <p><strong>MASTER / WIZARD:</strong> Pocas piezas iniciales, Â¡muy difÃ­cil!</p>
            <p>Pulsa un nivel para ver sus 24 retos. Usa <strong>â–¼/â–²</strong> para mostrar u ocultar la lista.</p>
            
            <h3>ðŸ’¾ Progreso</h3>
            <p>Tu progreso se guarda automÃ¡ticamente. Los retos completados aparecen resaltados en verde.</p>
            
            <button class="btn close-help" onclick="hideHelp()">Â¡Entendido!</button>
        </div>
    </div>
    
    <svg id="game-svg" viewBox="0 0 550 820">
        <defs>
            <linearGradient id="boardGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#ffffff"/>
                <stop offset="50%" stop-color="#f8f8f8"/>
                <stop offset="100%" stop-color="#f0f0f0"/>
            </linearGradient>
            
            <linearGradient id="buttonBg" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stop-color="#1a1a2e"/>
                <stop offset="100%" stop-color="#0f0f1a"/>
            </linearGradient>
            
            <!-- Crystal Silver (Intro) -->
            <linearGradient id="crystalSilver" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#e8e8f0"/>
                <stop offset="25%" stop-color="#c0c0d0"/>
                <stop offset="50%" stop-color="#a8a8b8"/>
                <stop offset="75%" stop-color="#c0c0d0"/>
                <stop offset="100%" stop-color="#808090"/>
            </linearGradient>
            
            <!-- Crystal Blue (H) -->
            <linearGradient id="crystalBlue" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#4050d0"/>
                <stop offset="50%" stop-color="#2030a0"/>
                <stop offset="100%" stop-color="#101060"/>
            </linearGradient>
            
            <!-- Crystal Red (D) -->
            <linearGradient id="crystalRed" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#ff4040"/>
                <stop offset="50%" stop-color="#d01010"/>
                <stop offset="100%" stop-color="#900000"/>
            </linearGradient>
            
            <!-- Crystal Purple (A) -->
            <linearGradient id="crystalPurple" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#a050d0"/>
                <stop offset="50%" stop-color="#7030a0"/>
                <stop offset="100%" stop-color="#401060"/>
            </linearGradient>
            
            <!-- Crystal Lime (B) -->
            <linearGradient id="crystalLime" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#c0e040"/>
                <stop offset="50%" stop-color="#90b020"/>
                <stop offset="100%" stop-color="#607010"/>
            </linearGradient>
            
            <!-- Crystal Orange (E) -->
            <linearGradient id="crystalOrange" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#ffa040"/>
                <stop offset="50%" stop-color="#e07000"/>
                <stop offset="100%" stop-color="#a04000"/>
            </linearGradient>
            
            <!-- Crystal Cyan (C) -->
            <linearGradient id="crystalCyan" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#40d0f0"/>
                <stop offset="50%" stop-color="#20a0c0"/>
                <stop offset="100%" stop-color="#107080"/>
            </linearGradient>
            
            <!-- Crystal Yellow (G) -->
            <!-- Crystal Yellow (G) -->
            <linearGradient id="crystalYellow" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#fff040"/>
                <stop offset="50%" stop-color="#d0b000"/>
                <stop offset="100%" stop-color="#908000"/>
            </linearGradient>
            
            <!-- Crystal Green (F) -->
            <linearGradient id="crystalGreen" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#40c040"/>
                <stop offset="50%" stop-color="#208020"/>
                <stop offset="100%" stop-color="#105010"/>
            </linearGradient>
            
            <linearGradient id="crystalShine" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stop-color="rgba(255,255,255,0.5)"/>
                <stop offset="40%" stop-color="rgba(255,255,255,0.1)"/>
                <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
            </linearGradient>
            
            <radialGradient id="sparkle" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="rgba(255,255,255,0.9)"/>
                <stop offset="50%" stop-color="rgba(255,255,255,0.3)"/>
                <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
            </radialGradient>
        </defs>
        
        <g id="board-group"></g>
        
        <!-- Pieces area background - white to highlight pieces -->
        <rect x="0" y="510" width="550" height="310" fill="#0a0a15" />
        <rect x="10" y="515" width="530" height="300" rx="10" fill="#e8e8e8" stroke="#2a2a3a" stroke-width="1"/>
        <text x="275" y="535" text-anchor="middle" fill="#666666" font-size="10" font-family="Orbitron">PIEZAS DISPONIBLES</text>
        
        <g id="pieces-group"></g>
    </svg>
    
    <!-- Control buttons - compact single line -->
    <div class="controls" id="game-controls">
        <button class="btn" ontouchend="rotatePiece(); event.preventDefault();" onclick="rotatePiece()">âŸ³</button>
        <button class="btn" ontouchend="flipPieceH(); event.preventDefault();" onclick="flipPieceH()">â†”H</button>
        <button class="btn" ontouchend="flipPieceV(); event.preventDefault();" onclick="flipPieceV()">â†•V</button>
        <button class="btn" ontouchend="resetPieces(); event.preventDefault();" onclick="resetPieces()">ðŸ”„</button>
        <button class="btn" ontouchend="giveHint(); event.preventDefault();" onclick="giveHint()">ðŸ’¡</button>
    </div>
    
    <!-- Category buttons - click to select, toggle button to show/hide grid -->
    <div class="controls" id="category-selector">
        <button class="btn cat-starter" id="btn-STARTER" onclick="selectLevel('STARTER')">STARTER <span id="prog-STARTER">0/24</span></button>
        <button class="btn cat-junior" id="btn-JUNIOR" onclick="selectLevel('JUNIOR')">JUNIOR <span id="prog-JUNIOR">0/24</span></button>
        <button class="btn cat-expert" id="btn-EXPERT" onclick="selectLevel('EXPERT')">EXPERT <span id="prog-EXPERT">0/24</span></button>
        <button class="btn cat-master" id="btn-MASTER" onclick="selectLevel('MASTER')">MASTER <span id="prog-MASTER">0/24</span></button>
        <button class="btn cat-wizard" id="btn-WIZARD" onclick="selectLevel('WIZARD')">WIZARD <span id="prog-WIZARD">0/24</span></button>
        <button class="btn" id="toggle-grid-btn" onclick="toggleGridVisibility()" style="padding: 6px 10px;">â–¼</button>
    </div>
    
    <!-- Challenge grid - 3 rows x 8 columns, hidden by default -->
    <div id="challenge-grid-container" class="hidden" style="width: 100%; max-width: 340px;">
        <div class="controls" id="challenge-grid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px;"></div>
    </div>
    
    <p class="info" id="current-info" style="display:none;">Selecciona un reto</p>
    
    <!-- Victory Overlay -->
    <div id="victory-overlay" class="victory-overlay hidden">
        <div class="victory-text">Â¡COMPLETADO!</div>
        <button class="btn" onclick="nextChallenge()">SIGUIENTE RETO â†’</button>
        <button class="btn" onclick="backToGrid()">VOLVER A RETOS</button>
    </div>

    <script>
    const SOLUCIONES = {"1":{"H":[22,23],"H_2":[33,34],"D":[7,17,24],"D_2":[30,31,32],"A":[4,12,13],"A_2":[2,8,9],"B":[6,16,21,35],"E":[18,25,26,27],"F":[0,1,3,10],"C":[5,14,15,20],"G":[11,19,28,29]},"2":{"H":[14,20],"H_2":[33,34],"D":[30,31,32],"D_2":[27,28,29],"A":[1,6,7],"A_2":[4,12,13],"B":[8,17,23,24],"E":[16,21,22,35],"F":[0,2,5,15],"C":[3,10,11,19],"G":[9,18,25,26]},"3":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[1,6,7],"A_2":[3,10,11],"B":[9,18,26,27],"E":[19,28,29,30],"F":[0,2,8,17],"C":[5,14,15,16],"G":[13,20,31,32]},"4":{"H":[18,27],"H_2":[4,12],"D":[24,25,26],"D_2":[33,34,35],"A":[2,8,9],"A_2":[5,14,15],"B":[0,3,10,11],"E":[19,28,29,30],"F":[17,21,22,23],"C":[1,6,7,16],"G":[13,20,31,32]},"5":{"H":[25,26],"H_2":[22,23],"D":[27,28,29],"D_2":[30,31,32],"A":[9,10,18],"A_2":[5,14,15],"B":[0,1,6,7],"E":[16,21,34,35],"F":[4,13,20,33],"C":[2,8,17,24],"G":[3,11,12,19]},"6":{"H":[24,25],"H_2":[21,22],"D":[8,17,23],"D_2":[33,34,35],"A":[3,10,11],"A_2":[5,14,15],"B":[12,19,29,30],"E":[18,26,27,28],"F":[0,2,4,9],"C":[1,6,7,16],"G":[13,20,31,32]},"7":{"H":[3,11],"H_2":[34,35],"D":[21,22,23],"D_2":[24,25,26],"A":[4,12,13],"A_2":[2,8,9],"B":[14,20,32,33],"E":[19,29,30,31],"F":[0,5,15,16],"C":[1,6,7,17],"G":[10,18,27,28]},"8":{"H":[33,34],"H_2":[30,31],"D":[0,2,9],"D_2":[27,28,29],"A":[5,14,15],"A_2":[1,6,7],"B":[8,17,23,24],"E":[16,21,22,35],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"9":{"H":[1,6],"H_2":[31,32],"D":[0,2,8],"D_2":[27,28,29],"A":[3,10,11],"A_2":[5,14,15],"B":[7,17,23,24],"E":[16,21,22,35],"F":[13,20,33,34],"C":[4,12,19,30],"G":[9,18,25,26]},"10":{"H":[21,22],"H_2":[5,14],"D":[30,31,32],"D_2":[33,34,35],"A":[2,8,9],"A_2":[6,15,16],"B":[10,18,26,27],"E":[17,23,24,25],"F":[0,1,3,7],"C":[4,12,13,20],"G":[11,19,28,29]},"11":{"H":[21,22],"H_2":[28,29],"D":[33,34,35],"D_2":[30,31,32],"A":[2,8,9],"A_2":[5,14,15],"B":[10,18,26,27],"E":[17,23,24,25],"F":[0,4,13,20],"C":[1,6,7,16],"G":[3,11,12,19]},"12":{"H":[27,28],"H_2":[21,22],"D":[14,20,32],"D_2":[33,34,35],"A":[3,10,11],"A_2":[4,12,13],"B":[8,17,23,24],"E":[19,29,30,31],"F":[0,2,5,15],"C":[1,6,7,16],"G":[9,18,25,26]},"13":{"H":[1,6],"H_2":[33,34],"D":[27,28,29],"D_2":[30,31,32],"A":[2,8,9],"A_2":[13,14,20],"B":[7,17,23,24],"E":[16,21,22,35],"F":[10,18,25,26],"C":[0,4,5,15],"G":[3,11,12,19]},"14":{"H":[30,31],"H_2":[21,22],"D":[10,18,26],"D_2":[27,28,29],"A":[5,14,15],"A_2":[1,6,7],"B":[0,2,8,9],"E":[17,23,24,25],"F":[16,33,34,35],"C":[4,13,20,32],"G":[3,11,12,19]},"15":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[0,3,11],"A":[2,8,9],"A_2":[5,14,15],"B":[10,18,26,27],"E":[19,28,29,30],"F":[16,33,34,35],"C":[1,6,7,17],"G":[13,20,31,32]},"16":{"H":[2,9],"H_2":[3,10],"D":[21,22,23],"D_2":[33,34,35],"A":[6,15,16],"A_2":[4,12,13],"B":[11,19,29,30],"E":[18,26,27,28],"F":[14,20,31,32],"C":[0,1,5,7],"G":[8,17,24,25]},"17":{"H":[30,31],"H_2":[34,35],"D":[12,19,29],"D_2":[21,22,23],"A":[1,6,7],"A_2":[3,10,11],"B":[13,20,32,33],"E":[18,26,27,28],"F":[0,2,4,9],"C":[5,14,15,16],"G":[8,17,24,25]},"18":{"H":[22,23],"H_2":[3,10],"D":[0,4,12],"D_2":[27,28,29],"A":[1,6,7],"A_2":[5,14,15],"B":[13,20,32,33],"E":[16,21,34,35],"F":[11,19,30,31],"C":[2,9,18,26],"G":[8,17,24,25]},"19":{"H":[34,35],"H_2":[27,28],"D":[24,25,26],"D_2":[21,22,23],"A":[4,12,13],"A_2":[5,14,15],"B":[11,19,29,30],"E":[20,31,32,33],"F":[0,2,8,17],"C":[1,6,7,16],"G":[3,9,10,18]},"20":{"H":[33,34],"H_2":[1,6],"D":[27,28,29],"D_2":[0,2,8],"A":[5,14,15],"A_2":[3,10,11],"B":[7,17,23,24],"E":[16,21,22,35],"F":[19,30,31,32],"C":[4,12,13,20],"G":[9,18,25,26]},"21":{"H":[27,28],"H_2":[24,25],"D":[21,22,23],"D_2":[0,4,12],"A":[3,10,11],"A_2":[5,14,15],"B":[13,20,32,33],"E":[19,29,30,31],"F":[6,16,34,35],"C":[2,9,18,26],"G":[1,7,8,17]},"22":{"H":[5,15],"H_2":[27,28],"D":[24,25,26],"D_2":[30,31,32],"A":[4,12,13],"A_2":[14,20,33],"B":[0,1,6,7],"E":[16,21,34,35],"F":[8,17,22,23],"C":[3,11,19,29],"G":[2,9,10,18]},"23":{"H":[30,31],"H_2":[34,35],"D":[21,22,23],"D_2":[27,28,29],"A":[9,10,18],"A_2":[5,14,15],"B":[13,20,32,33],"E":[0,2,4,8],"F":[17,24,25,26],"C":[1,6,7,16],"G":[3,11,12,19]},"24":{"H":[5,14],"H_2":[27,28],"D":[21,22,23],"D_2":[0,4,12],"A":[1,6,7],"A_2":[3,10,11],"B":[13,20,32,33],"E":[19,29,30,31],"F":[17,24,25,26],"C":[2,8,9,18],"G":[15,16,34,35]},"25":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[3,10,11],"A_2":[5,14,15],"B":[9,18,26,27],"E":[19,28,29,30],"F":[0,2,8,17],"C":[1,6,7,16],"G":[13,20,31,32]},"26":{"H":[27,28],"H_2":[25,26],"D":[12,19,29],"D_2":[30,31,32],"A":[3,10,11],"A_2":[1,6,7],"B":[15,16,21,35],"E":[17,22,23,24],"F":[13,20,33,34],"C":[2,8,9,18],"G":[0,4,5,14]},"27":{"H":[25,26],"H_2":[30,31],"D":[27,28,29],"D_2":[33,34,35],"A":[1,6,7],"A_2":[9,10,18],"B":[8,17,23,24],"E":[0,2,5,14],"F":[15,16,21,22],"C":[4,13,20,32],"G":[3,11,12,19]},"28":{"H":[25,26],"H_2":[12,19],"D":[27,28,29],"D_2":[30,31,32],"A":[2,8,9],"A_2":[1,6,7],"B":[15,16,21,35],"E":[17,22,23,24],"F":[13,20,33,34],"C":[3,10,11,18],"G":[0,4,5,14]},"29":{"H":[12,19],"H_2":[30,31],"D":[24,25,26],"D_2":[27,28,29],"A":[5,14,15],"A_2":[3,10,11],"B":[13,20,32,33],"E":[16,21,34,35],"F":[0,1,4,6],"C":[2,8,9,18],"G":[7,17,22,23]},"30":{"H":[9,18],"H_2":[27,28],"D":[33,34,35],"D_2":[24,25,26],"A":[3,10,11],"A_2":[5,14,15],"B":[12,19,29,30],"E":[0,2,4,8],"F":[16,21,22,23],"C":[1,6,7,17],"G":[13,20,31,32]},"31":{"H":[3,10],"H_2":[34,35],"D":[27,28,29],"D_2":[30,31,32],"A":[11,12,19],"A_2":[1,6,7],"B":[8,17,23,24],"E":[0,2,4,13],"F":[15,16,21,22],"C":[5,14,20,33],"G":[9,18,25,26]},"32":{"H":[2,9],"H_2":[3,10],"D":[30,31,32],"D_2":[33,34,35],"A":[11,19,29],"A_2":[1,6,7],"B":[0,5,14,15],"E":[18,26,27,28],"F":[16,21,22,23],"C":[4,12,13,20],"G":[8,17,24,25]},"33":{"H":[33,34],"H_2":[3,11],"D":[27,28,29],"D_2":[0,1,7],"A":[2,8,9],"A_2":[5,14,15],"B":[6,16,21,35],"E":[17,22,23,24],"F":[10,18,25,26],"C":[4,12,19,30],"G":[13,20,31,32]},"34":{"H":[22,23],"H_2":[28,29],"D":[24,25,26],"D_2":[30,31,32],"A":[2,8,9],"A_2":[10,18,27],"B":[0,5,14,15],"E":[16,21,34,35],"F":[4,13,20,33],"C":[1,6,7,17],"G":[3,11,12,19]},"35":{"H":[5,15],"H_2":[17,23],"D":[27,28,29],"D_2":[24,25,26],"A":[1,6,7],"A_2":[4,12,13],"B":[0,2,8,9],"E":[16,21,22,35],"F":[19,30,31,32],"C":[3,10,11,18],"G":[14,20,33,34]},"36":{"H":[28,29],"H_2":[21,22],"D":[0,4,12],"D_2":[33,34,35],"A":[2,8,9],"A_2":[5,14,15],"B":[10,18,26,27],"E":[17,23,24,25],"F":[3,11,19,30],"C":[1,6,7,16],"G":[13,20,31,32]},"37":{"H":[25,26],"H_2":[5,14],"D":[15,16,21],"D_2":[33,34,35],"A":[2,8,9],"A_2":[3,10,11],"B":[0,1,6,7],"E":[17,22,23,24],"F":[18,27,28,29],"C":[4,12,19,30],"G":[13,20,31,32]},"38":{"H":[3,11],"H_2":[27,28],"D":[24,25,26],"D_2":[33,34,35],"A":[5,14,15],"A_2":[9,10,18],"B":[12,19,29,30],"E":[0,2,4,8],"F":[16,21,22,23],"C":[1,6,7,17],"G":[13,20,31,32]},"39":{"H":[24,25],"H_2":[31,32],"D":[0,5,14],"D_2":[21,22,23],"A":[3,10,11],"A_2":[2,8,9],"B":[12,19,29,30],"E":[18,26,27,28],"F":[4,13,20,33],"C":[1,6,7,17],"G":[15,16,34,35]},"40":{"H":[25,26],"H_2":[21,22],"D":[27,28,29],"D_2":[33,34,35],"A":[9,10,18],"A_2":[5,14,15],"B":[8,17,23,24],"E":[0,2,4,13],"F":[20,30,31,32],"C":[1,6,7,16],"G":[3,11,12,19]},"41":{"H":[24,25],"H_2":[21,22],"D":[8,17,23],"D_2":[33,34,35],"A":[3,10,11],"A_2":[1,6,7],"B":[9,18,26,27],"E":[19,28,29,30],"F":[0,2,4,12],"C":[5,14,15,16],"G":[13,20,31,32]},"42":{"H":[1,7],"H_2":[30,31],"D":[18,26,27],"D_2":[33,34,35],"A":[3,10,11],"A_2":[2,8,9],"B":[0,5,14,15],"E":[17,23,24,25],"F":[12,19,28,29],"C":[4,13,20,32],"G":[6,16,21,22]},"43":{"H":[25,26],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[8,17,24],"A_2":[3,10,11],"B":[0,5,14,15],"E":[19,28,29,30],"F":[2,9,18,27],"C":[1,6,7,16],"G":[13,20,31,32]},"44":{"H":[28,29],"H_2":[5,14],"D":[0,2,9],"D_2":[33,34,35],"A":[1,6,7],"A_2":[3,10,11],"B":[8,17,23,24],"E":[18,25,26,27],"F":[15,16,21,22],"C":[4,12,19,30],"G":[13,20,31,32]},"45":{"H":[0,3],"H_2":[5,14],"D":[30,31,32],"D_2":[33,34,35],"A":[1,6,7],"A_2":[2,8,9],"B":[10,18,26,27],"E":[17,23,24,25],"F":[15,16,21,22],"C":[4,12,13,20],"G":[11,19,28,29]},"46":{"H":[3,11],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[1,6,7],"A_2":[10,18,27],"B":[0,2,8,9],"E":[19,28,29,30],"F":[17,24,25,26],"C":[5,14,15,16],"G":[13,20,31,32]},"47":{"H":[3,11],"H_2":[21,22],"D":[27,28,29],"D_2":[30,31,32],"A":[14,20,33],"A_2":[1,6,7],"B":[8,17,23,24],"E":[0,2,5,9],"F":[10,18,25,26],"C":[4,12,13,19],"G":[15,16,34,35]},"48":{"H":[25,26],"H_2":[21,22],"D":[9,18,27],"D_2":[33,34,35],"A":[3,10,11],"A_2":[1,6,7],"B":[8,17,23,24],"E":[19,28,29,30],"F":[0,2,4,12],"C":[5,14,15,16],"G":[13,20,31,32]},"49":{"H":[34,35],"H_2":[4,13],"D":[24,25,26],"D_2":[0,3,11],"A":[2,8,9],"A_2":[5,14,15],"B":[12,19,29,30],"E":[20,31,32,33],"F":[16,21,22,23],"C":[1,6,7,17],"G":[10,18,27,28]},"50":{"H":[27,28],"H_2":[5,14],"D":[19,29,30],"D_2":[21,22,23],"A":[1,6,7],"A_2":[4,12,13],"B":[0,3,10,11],"E":[20,31,32,33],"F":[17,24,25,26],"C":[2,8,9,18],"G":[15,16,34,35]},"51":{"H":[30,31],"H_2":[33,34],"D":[27,28,29],"D_2":[17,23,24],"A":[1,6,7],"A_2":[5,14,15],"B":[0,2,8,9],"E":[16,21,22,35],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"52":{"H":[2,8],"H_2":[34,35],"D":[24,25,26],"D_2":[27,28,29],"A":[9,10,18],"A_2":[4,12,13],"B":[0,5,14,15],"E":[20,31,32,33],"F":[3,11,19,30],"C":[1,6,16,21],"G":[7,17,22,23]},"53":{"H":[0,1],"H_2":[4,13],"D":[30,31,32],"D_2":[33,34,35],"A":[2,8,9],"A_2":[3,10,11],"B":[7,17,23,24],"E":[18,25,26,27],"F":[12,19,28,29],"C":[5,14,15,20],"G":[6,16,21,22]},"54":{"H":[2,8],"H_2":[22,23],"D":[24,25,26],"D_2":[27,28,29],"A":[9,10,18],"A_2":[5,14,15],"B":[13,20,32,33],"E":[16,21,34,35],"F":[11,19,30,31],"C":[1,6,7,17],"G":[0,3,4,12]},"55":{"H":[6,16],"H_2":[21,22],"D":[30,31,32],"D_2":[33,34,35],"A":[2,8,9],"A_2":[4,12,13],"B":[7,17,23,24],"E":[18,25,26,27],"F":[0,1,3,10],"C":[5,14,15,20],"G":[11,19,28,29]},"56":{"H":[1,7],"H_2":[33,34],"D":[27,28,29],"D_2":[30,31,32],"A":[2,8,9],"A_2":[13,14,20],"B":[6,16,21,35],"E":[17,22,23,24],"F":[10,18,25,26],"C":[0,4,5,15],"G":[3,11,12,19]},"57":{"H":[30,31],"H_2":[5,15],"D":[24,25,26],"D_2":[0,1,6],"A":[2,8,9],"A_2":[4,12,13],"B":[14,20,32,33],"E":[16,21,34,35],"F":[19,27,28,29],"C":[3,10,11,18],"G":[7,17,22,23]},"58":{"H":[24,25],"H_2":[4,12],"D":[0,2,8],"D_2":[21,22,23],"A":[3,10,11],"A_2":[5,14,15],"B":[9,18,26,27],"E":[19,28,29,30],"F":[16,33,34,35],"C":[1,6,7,17],"G":[13,20,31,32]},"59":{"H":[22,23],"H_2":[33,34],"D":[27,28,29],"D_2":[14,20,32],"A":[1,6,7],"A_2":[4,12,13],"B":[15,16,21,35],"E":[0,3,5,10],"F":[11,19,30,31],"C":[2,9,18,26],"G":[8,17,24,25]},"60":{"H":[28,29],"H_2":[30,31],"D":[24,25,26],"D_2":[21,22,23],"A":[10,18,27],"A_2":[5,14,15],"B":[13,20,32,33],"E":[0,1,4,7],"F":[6,16,34,35],"C":[2,8,9,17],"G":[3,11,12,19]},"61":{"H":[33,34],"H_2":[30,31],"D":[27,28,29],"D_2":[0,1,7],"A":[5,14,15],"A_2":[2,8,9],"B":[6,16,21,35],"E":[17,22,23,24],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"62":{"H":[34,35],"H_2":[25,26],"D":[27,28,29],"D_2":[30,31,32],"A":[1,6,7],"A_2":[9,10,18],"B":[8,17,23,24],"E":[0,2,4,13],"F":[15,16,21,22],"C":[5,14,20,33],"G":[3,11,12,19]},"63":{"H":[33,34],"H_2":[30,31],"D":[27,28,29],"D_2":[0,1,6],"A":[2,8,9],"A_2":[5,14,15],"B":[7,17,23,24],"E":[16,21,22,35],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"64":{"H":[28,29],"H_2":[5,14],"D":[24,25,26],"D_2":[21,22,23],"A":[10,18,27],"A_2":[1,6,7],"B":[0,4,12,13],"E":[20,31,32,33],"F":[3,11,19,30],"C":[2,8,9,17],"G":[15,16,34,35]},"65":{"H":[25,26],"H_2":[4,12],"D":[16,21,35],"D_2":[30,31,32],"A":[1,6,7],"A_2":[2,8,9],"B":[0,5,14,15],"E":[17,22,23,24],"F":[13,20,33,34],"C":[3,10,18,27],"G":[11,19,28,29]},"66":{"H":[28,29],"H_2":[30,31],"D":[24,25,26],"D_2":[9,18,27],"A":[4,12,13],"A_2":[5,14,15],"B":[6,16,21,35],"E":[20,32,33,34],"F":[8,17,22,23],"C":[3,10,11,19],"G":[0,1,2,7]},"67":{"H":[3,11],"H_2":[33,34],"D":[27,28,29],"D_2":[0,2,9],"A":[1,6,7],"A_2":[5,14,15],"B":[8,17,23,24],"E":[16,21,22,35],"F":[10,18,25,26],"C":[4,12,19,30],"G":[13,20,31,32]},"68":{"H":[27,28],"H_2":[30,31],"D":[24,25,26],"D_2":[12,19,29],"A":[3,10,11],"A_2":[5,14,15],"B":[6,16,21,35],"E":[20,32,33,34],"F":[0,1,4,13],"C":[2,8,9,18],"G":[7,17,22,23]},"69":{"H":[2,9],"H_2":[3,10],"D":[30,31,32],"D_2":[33,34,35],"A":[1,6,7],"A_2":[13,14,20],"B":[8,17,23,24],"E":[18,25,26,27],"F":[15,16,21,22],"C":[0,4,5,12],"G":[11,19,28,29]},"70":{"H":[1,6],"H_2":[28,29],"D":[21,22,23],"D_2":[33,34,35],"A":[3,10,11],"A_2":[12,19,30],"B":[9,18,26,27],"E":[0,2,4,8],"F":[7,17,24,25],"C":[5,14,15,16],"G":[13,20,31,32]},"71":{"H":[24,25],"H_2":[1,6],"D":[21,22,23],"D_2":[33,34,35],"A":[3,10,11],"A_2":[7,8,17],"B":[9,18,26,27],"E":[19,28,29,30],"F":[0,2,4,12],"C":[5,14,15,16],"G":[13,20,31,32]},"72":{"H":[1,6],"H_2":[5,14],"D":[27,28,29],"D_2":[24,25,26],"A":[4,12,13],"A_2":[9,10,18],"B":[15,16,21,35],"E":[20,32,33,34],"F":[11,19,30,31],"C":[0,2,3,8],"G":[7,17,22,23]},"73":{"H":[22,23],"H_2":[28,29],"D":[24,25,26],"D_2":[30,31,32],"A":[2,8,9],"A_2":[10,18,27],"B":[0,5,14,15],"E":[16,21,34,35],"F":[4,13,20,33],"C":[1,6,7,17],"G":[3,11,12,19]},"74":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[0,3,11],"A":[2,8,9],"A_2":[5,14,15],"B":[10,18,26,27],"E":[19,28,29,30],"F":[16,33,34,35],"C":[1,6,7,17],"G":[13,20,31,32]},"75":{"H":[22,23],"H_2":[33,34],"D":[7,17,24],"D_2":[30,31,32],"A":[4,12,13],"A_2":[2,8,9],"B":[6,16,21,35],"E":[18,25,26,27],"F":[0,1,3,10],"C":[5,14,15,20],"G":[11,19,28,29]},"76":{"H":[25,26],"H_2":[4,12],"D":[16,21,35],"D_2":[30,31,32],"A":[1,6,7],"A_2":[2,8,9],"B":[0,5,14,15],"E":[17,22,23,24],"F":[13,20,33,34],"C":[3,10,18,27],"G":[11,19,28,29]},"77":{"H":[22,23],"H_2":[7,17],"D":[33,34,35],"D_2":[24,25,26],"A":[3,10,11],"A_2":[5,14,15],"B":[12,19,29,30],"E":[0,2,4,8],"F":[9,18,27,28],"C":[1,6,16,21],"G":[13,20,31,32]},"78":{"H":[14,20],"H_2":[33,34],"D":[30,31,32],"D_2":[27,28,29],"A":[1,6,7],"A_2":[4,12,13],"B":[8,17,23,24],"E":[16,21,22,35],"F":[0,2,5,15],"C":[3,10,11,19],"G":[9,18,25,26]},"79":{"H":[27,28],"H_2":[21,22],"D":[30,31,32],"D_2":[33,34,35],"A":[2,8,9],"A_2":[13,14,20],"B":[7,17,23,24],"E":[0,1,4,12],"F":[10,18,25,26],"C":[3,11,19,29],"G":[5,6,15,16]},"80":{"H":[34,35],"H_2":[25,26],"D":[27,28,29],"D_2":[30,31,32],"A":[1,6,7],"A_2":[9,10,18],"B":[8,17,23,24],"E":[0,2,4,13],"F":[15,16,21,22],"C":[5,14,20,33],"G":[3,11,12,19]},"81":{"H":[33,34],"H_2":[3,11],"D":[27,28,29],"D_2":[0,1,7],"A":[2,8,9],"A_2":[5,14,15],"B":[6,16,21,35],"E":[17,22,23,24],"F":[10,18,25,26],"C":[4,12,19,30],"G":[13,20,31,32]},"82":{"H":[2,8],"H_2":[34,35],"D":[24,25,26],"D_2":[27,28,29],"A":[9,10,18],"A_2":[4,12,13],"B":[0,5,14,15],"E":[20,31,32,33],"F":[3,11,19,30],"C":[1,6,16,21],"G":[7,17,22,23]},"83":{"H":[33,34],"H_2":[30,31],"D":[27,28,29],"D_2":[0,1,7],"A":[5,14,15],"A_2":[2,8,9],"B":[6,16,21,35],"E":[17,22,23,24],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"84":{"H":[27,28],"H_2":[31,32],"D":[19,29,30],"D_2":[33,34,35],"A":[2,8,9],"A_2":[4,12,13],"B":[7,17,23,24],"E":[0,1,3,11],"F":[10,18,25,26],"C":[5,14,15,20],"G":[6,16,21,22]},"85":{"H":[28,29],"H_2":[5,14],"D":[0,2,9],"D_2":[33,34,35],"A":[1,6,7],"A_2":[3,10,11],"B":[8,17,23,24],"E":[18,25,26,27],"F":[15,16,21,22],"C":[4,12,19,30],"G":[13,20,31,32]},"86":{"H":[25,26],"H_2":[21,22],"D":[27,28,29],"D_2":[30,31,32],"A":[1,6,7],"A_2":[11,12,19],"B":[8,17,23,24],"E":[0,2,4,13],"F":[16,33,34,35],"C":[5,14,15,20],"G":[3,9,10,18]},"87":{"H":[30,31],"H_2":[4,12],"D":[27,28,29],"D_2":[33,34,35],"A":[1,6,7],"A_2":[13,20,32],"B":[8,17,23,24],"E":[0,2,5,14],"F":[15,16,21,22],"C":[3,10,11,19],"G":[9,18,25,26]},"88":{"H":[25,26],"H_2":[12,19],"D":[27,28,29],"D_2":[30,31,32],"A":[2,8,9],"A_2":[1,6,7],"B":[15,16,21,35],"E":[17,22,23,24],"F":[13,20,33,34],"C":[3,10,11,18],"G":[0,4,5,14]},"89":{"H":[28,29],"H_2":[30,31],"D":[24,25,26],"D_2":[9,18,27],"A":[4,12,13],"A_2":[5,14,15],"B":[6,16,21,35],"E":[20,32,33,34],"F":[8,17,22,23],"C":[3,10,11,19],"G":[0,1,2,7]},"90":{"H":[28,29],"H_2":[5,14],"D":[24,25,26],"D_2":[21,22,23],"A":[10,18,27],"A_2":[1,6,7],"B":[0,4,12,13],"E":[20,31,32,33],"F":[3,11,19,30],"C":[2,8,9,17],"G":[15,16,34,35]},"91":{"H":[1,6],"H_2":[31,32],"D":[0,2,8],"D_2":[27,28,29],"A":[3,10,11],"A_2":[5,14,15],"B":[7,17,23,24],"E":[16,21,22,35],"F":[13,20,33,34],"C":[4,12,19,30],"G":[9,18,25,26]},"92":{"H":[5,15],"H_2":[17,23],"D":[27,28,29],"D_2":[24,25,26],"A":[1,6,7],"A_2":[4,12,13],"B":[0,2,8,9],"E":[16,21,22,35],"F":[19,30,31,32],"C":[3,10,11,18],"G":[14,20,33,34]},"93":{"H":[24,25],"H_2":[31,32],"D":[0,5,14],"D_2":[21,22,23],"A":[3,10,11],"A_2":[2,8,9],"B":[12,19,29,30],"E":[18,26,27,28],"F":[4,13,20,33],"C":[1,6,7,17],"G":[15,16,34,35]},"94":{"H":[33,34],"H_2":[30,31],"D":[27,28,29],"D_2":[0,1,6],"A":[2,8,9],"A_2":[5,14,15],"B":[7,17,23,24],"E":[16,21,22,35],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"95":{"H":[0,3],"H_2":[5,14],"D":[30,31,32],"D_2":[33,34,35],"A":[1,6,7],"A_2":[2,8,9],"B":[10,18,26,27],"E":[17,23,24,25],"F":[15,16,21,22],"C":[4,12,13,20],"G":[11,19,28,29]},"96":{"H":[27,28],"H_2":[4,13],"D":[21,22,23],"D_2":[24,25,26],"A":[5,14,15],"A_2":[9,10,18],"B":[12,19,29,30],"E":[20,31,32,33],"F":[6,16,34,35],"C":[0,2,3,11],"G":[1,7,8,17]},"97":{"H":[34,35],"H_2":[4,13],"D":[24,25,26],"D_2":[21,22,23],"A":[3,10,11],"A_2":[6,15,16],"B":[12,19,29,30],"E":[20,31,32,33],"F":[9,18,27,28],"C":[0,1,5,14],"G":[2,7,8,17]},"98":{"H":[34,35],"H_2":[31,32],"D":[27,28,29],"D_2":[13,20,33],"A":[3,10,11],"A_2":[1,6,7],"B":[8,17,23,24],"E":[0,2,5,14],"F":[15,16,21,22],"C":[4,12,19,30],"G":[9,18,25,26]},"99":{"H":[2,9],"H_2":[3,10],"D":[30,31,32],"D_2":[33,34,35],"A":[1,6,7],"A_2":[13,14,20],"B":[8,17,23,24],"E":[18,25,26,27],"F":[15,16,21,22],"C":[0,4,5,12],"G":[11,19,28,29]},"100":{"H":[3,10],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[6,15,16],"A_2":[2,8,9],"B":[11,19,29,30],"E":[18,26,27,28],"F":[7,17,24,25],"C":[0,1,5,14],"G":[13,20,31,32]},"101":{"H":[34,35],"H_2":[4,13],"D":[24,25,26],"D_2":[0,3,11],"A":[2,8,9],"A_2":[5,14,15],"B":[12,19,29,30],"E":[20,31,32,33],"F":[16,21,22,23],"C":[1,6,7,17],"G":[10,18,27,28]},"102":{"H":[2,9],"H_2":[3,10],"D":[21,22,23],"D_2":[33,34,35],"A":[6,15,16],"A_2":[4,12,13],"B":[11,19,29,30],"E":[18,26,27,28],"F":[14,20,31,32],"C":[0,1,5,7],"G":[8,17,24,25]},"103":{"H":[21,22],"H_2":[28,29],"D":[33,34,35],"D_2":[30,31,32],"A":[2,8,9],"A_2":[5,14,15],"B":[10,18,26,27],"E":[17,23,24,25],"F":[0,4,13,20],"C":[1,6,7,16],"G":[3,11,12,19]},"104":{"H":[2,8],"H_2":[22,23],"D":[24,25,26],"D_2":[30,31,32],"A":[11,19,29],"A_2":[4,12,13],"B":[15,16,21,35],"E":[0,3,5,10],"F":[9,18,27,28],"C":[1,6,7,17],"G":[14,20,33,34]},"105":{"H":[30,31],"H_2":[5,15],"D":[24,25,26],"D_2":[0,1,6],"A":[2,8,9],"A_2":[4,12,13],"B":[14,20,32,33],"E":[16,21,34,35],"F":[19,27,28,29],"C":[3,10,11,18],"G":[7,17,22,23]},"106":{"H":[28,29],"H_2":[21,22],"D":[0,4,12],"D_2":[33,34,35],"A":[2,8,9],"A_2":[5,14,15],"B":[10,18,26,27],"E":[17,23,24,25],"F":[3,11,19,30],"C":[1,6,7,16],"G":[13,20,31,32]},"107":{"H":[33,34],"H_2":[27,28],"D":[24,25,26],"D_2":[8,17,23],"A":[1,6,7],"A_2":[5,14,15],"B":[12,19,29,30],"E":[16,21,22,35],"F":[0,2,4,9],"C":[3,10,11,18],"G":[13,20,31,32]},"108":{"H":[18,27],"H_2":[4,12],"D":[24,25,26],"D_2":[33,34,35],"A":[2,8,9],"A_2":[5,14,15],"B":[0,3,10,11],"E":[19,28,29,30],"F":[17,21,22,23],"C":[1,6,7,16],"G":[13,20,31,32]},"109":{"H":[3,11],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[1,6,7],"A_2":[10,18,27],"B":[0,2,8,9],"E":[19,28,29,30],"F":[17,24,25,26],"C":[5,14,15,16],"G":[13,20,31,32]},"110":{"H":[28,29],"H_2":[3,11],"D":[0,5,14],"D_2":[33,34,35],"A":[2,8,9],"A_2":[1,6,7],"B":[10,18,26,27],"E":[17,23,24,25],"F":[15,16,21,22],"C":[4,12,19,30],"G":[13,20,31,32]},"111":{"H":[27,28],"H_2":[25,26],"D":[12,19,29],"D_2":[30,31,32],"A":[3,10,11],"A_2":[1,6,7],"B":[15,16,21,35],"E":[17,22,23,24],"F":[13,20,33,34],"C":[2,8,9,18],"G":[0,4,5,14]},"112":{"H":[3,10],"H_2":[34,35],"D":[27,28,29],"D_2":[30,31,32],"A":[11,12,19],"A_2":[1,6,7],"B":[8,17,23,24],"E":[0,2,4,13],"F":[15,16,21,22],"C":[5,14,20,33],"G":[9,18,25,26]},"113":{"H":[25,26],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[8,17,24],"A_2":[3,10,11],"B":[0,5,14,15],"E":[19,28,29,30],"F":[2,9,18,27],"C":[1,6,7,16],"G":[13,20,31,32]},"114":{"H":[33,34],"H_2":[30,31],"D":[0,2,9],"D_2":[27,28,29],"A":[5,14,15],"A_2":[1,6,7],"B":[8,17,23,24],"E":[16,21,22,35],"F":[10,18,25,26],"C":[4,13,20,32],"G":[3,11,12,19]},"115":{"H":[27,28],"H_2":[30,31],"D":[24,25,26],"D_2":[12,19,29],"A":[3,10,11],"A_2":[5,14,15],"B":[6,16,21,35],"E":[20,32,33,34],"F":[0,1,4,13],"C":[2,8,9,18],"G":[7,17,22,23]},"116":{"H":[5,15],"H_2":[27,28],"D":[24,25,26],"D_2":[30,31,32],"A":[4,12,13],"A_2":[14,20,33],"B":[0,1,6,7],"E":[16,21,34,35],"F":[8,17,22,23],"C":[3,11,19,29],"G":[2,9,10,18]},"117":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[1,6,7],"A_2":[3,10,11],"B":[9,18,26,27],"E":[19,28,29,30],"F":[0,2,8,17],"C":[5,14,15,16],"G":[13,20,31,32]},"118":{"H":[27,28],"H_2":[21,22],"D":[14,20,32],"D_2":[33,34,35],"A":[3,10,11],"A_2":[4,12,13],"B":[8,17,23,24],"E":[19,29,30,31],"F":[0,2,5,15],"C":[1,6,7,16],"G":[9,18,25,26]},"119":{"H":[25,26],"H_2":[5,14],"D":[15,16,21],"D_2":[33,34,35],"A":[2,8,9],"A_2":[3,10,11],"B":[0,1,6,7],"E":[17,22,23,24],"F":[18,27,28,29],"C":[4,12,19,30],"G":[13,20,31,32]},"120":{"H":[22,23],"H_2":[28,29],"D":[24,25,26],"D_2":[30,31,32],"A":[10,18,27],"A_2":[5,14,15],"B":[0,1,6,7],"E":[16,21,34,35],"F":[4,13,20,33],"C":[2,8,9,17],"G":[3,11,12,19]}};
    const CATEGORIAS = {'STARTER':{start:1,end:24},'JUNIOR':{start:25,end:48},'EXPERT':{start:49,end:72},'MASTER':{start:73,end:96},'WIZARD':{start:97,end:120}};
    const INICIOS = {"1":{"H":[22,23],"H_2":[33,34],"D":[7,17,24],"D_2":[30,31,32],"A":[4,12,13],"E":[18,25,26,27],"F":[0,1,3,10]},"2":{"H":[14,20],"D":[27,28,29],"A":[1,6,7],"A_2":[4,12,13],"B":[8,17,23,24],"C":[3,10,11,19],"G":[9,18,25,26]},"3":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[33,34,35],"A":[1,6,7],"F":[0,2,8,17],"C":[5,14,15,16],"G":[13,20,31,32]},"4":{"H":[18,27],"H_2":[4,12],"D":[24,25,26],"A":[5,14,15],"B":[0,3,10,11],"C":[1,6,7,16]},"5":{"H":[25,26],"B":[0,1,6,7],"F":[4,13,20,33],"C":[2,8,17,24],"G":[3,11,12,19]},"6":{"H":[21,22],"D":[8,17,23],"A":[3,10,11],"A_2":[5,14,15],"F":[0,2,4,9],"C":[1,6,7,16]},"7":{"H":[34,35],"D":[21,22,23],"D_2":[24,25,26],"B":[14,20,32,33],"F":[0,5,15,16],"C":[1,6,7,17]},"8":{"H":[33,34],"H_2":[30,31],"D":[0,2,9],"D_2":[27,28,29],"A":[5,14,15],"A_2":[1,6,7]},"9":{"H":[1,6],"B":[7,17,23,24],"E":[16,21,22,35],"C":[4,12,19,30],"G":[9,18,25,26]},"10":{"H":[21,22],"H_2":[5,14],"A":[2,8,9],"A_2":[6,15,16],"B":[10,18,26,27],"G":[11,19,28,29]},"11":{"H":[28,29],"D":[30,31,32],"A":[2,8,9],"A_2":[5,14,15],"E":[17,23,24,25],"F":[0,4,13,20]},"12":{"H":[27,28],"H_2":[21,22],"D":[14,20,32],"D_2":[33,34,35],"C":[1,6,7,16],"G":[9,18,25,26]},"13":{"H":[1,6],"A":[2,8,9],"A_2":[13,14,20],"B":[7,17,23,24],"F":[10,18,25,26]},"14":{"H":[30,31],"H_2":[21,22],"B":[0,2,8,9],"F":[16,33,34,35],"G":[3,11,12,19]},"15":{"H":[24,25],"H_2":[4,12],"D":[21,22,23],"D_2":[0,3,11],"C":[1,6,7,17]},"16":{"H":[2,9],"H_2":[3,10],"A":[6,15,16],"A_2":[4,12,13],"E":[18,26,27,28]},"17":{"D":[12,19,29],"D_2":[21,22,23],"E":[18,26,27,28],"C":[5,14,15,16],"G":[8,17,24,25]},"18":{"H":[22,23],"D":[0,4,12],"B":[13,20,32,33],"E":[16,21,34,35],"G":[8,17,24,25]},"19":{"D":[24,25,26],"D_2":[21,22,23],"F":[0,2,8,17],"C":[1,6,7,16],"G":[3,9,10,18]},"20":{"H":[1,6],"B":[7,17,23,24],"F":[19,30,31,32],"C":[4,12,13,20]},"21":{"H":[24,25],"B":[13,20,32,33],"C":[2,9,18,26],"G":[1,7,8,17]},"22":{"H":[5,15],"A":[4,12,13],"B":[0,1,6,7],"G":[2,9,10,18]},"23":{"D":[21,22,23],"D_2":[27,28,29],"C":[1,6,7,16],"G":[3,11,12,19]},"24":{"D":[0,4,12],"A":[3,10,11],"F":[17,24,25,26],"G":[15,16,34,35]},"25":{"H":[24,25],"H_2":[4,12],"A":[5,14,15],"F":[0,2,8,17]},"26":{"H":[27,28],"H_2":[25,26],"D":[12,19,29],"A":[3,10,11],"A_2":[1,6,7],"C":[2,8,9,18]},"27":{"E":[0,2,5,14],"F":[15,16,21,22],"G":[3,11,12,19]},"28":{"H":[12,19],"D":[27,28,29],"C":[3,10,11,18],"G":[0,4,5,14]},"29":{"H":[12,19],"E":[16,21,34,35],"C":[2,8,9,18]},"30":{"H":[9,18],"D":[33,34,35],"D_2":[24,25,26],"C":[1,6,7,17]},"31":{"H":[3,10],"E":[0,2,4,13],"C":[5,14,20,33]},"32":{"A":[11,19,29],"A_2":[1,6,7],"B":[0,5,14,15],"F":[16,21,22,23]},"33":{"H":[3,11],"D":[27,28,29],"D_2":[0,1,7],"C":[4,12,19,30]},"34":{"A":[2,8,9],"B":[0,5,14,15],"F":[4,13,20,33],"C":[1,6,7,17]},"35":{"H":[17,23],"A":[1,6,7],"B":[0,2,8,9],"F":[19,30,31,32]},"36":{"H":[28,29],"H_2":[21,22],"D":[0,4,12],"C":[1,6,7,16]},"37":{"H":[5,14],"D":[15,16,21],"D_2":[33,34,35],"B":[0,1,6,7],"G":[13,20,31,32]},"38":{"H":[3,11],"H_2":[27,28],"A":[5,14,15],"A_2":[9,10,18],"F":[16,21,22,23]},"39":{"D":[21,22,23],"F":[4,13,20,33],"C":[1,6,7,17],"G":[15,16,34,35]},"40":{"A":[9,10,18],"F":[20,30,31,32],"C":[1,6,7,16]},"41":{"D":[8,17,23],"A":[1,6,7],"F":[0,2,4,12],"G":[13,20,31,32]},"42":{"B":[0,5,14,15],"E":[17,23,24,25],"F":[12,19,28,29]},"43":{"H":[25,26],"B":[0,5,14,15],"F":[2,9,18,27]},"44":{"D":[0,2,9],"D_2":[33,34,35],"G":[13,20,31,32]},"45":{"H":[0,3],"A":[1,6,7],"G":[11,19,28,29]},"46":{"A":[1,6,7],"A_2":[10,18,27],"F":[17,24,25,26]},"47":{"H":[21,22],"D":[27,28,29],"D_2":[30,31,32],"B":[8,17,23,24],"G":[15,16,34,35]},"48":{"H":[21,22],"A":[1,6,7],"B":[8,17,23,24],"F":[0,2,4,12],"C":[5,14,15,16]},"49":{"H":[4,13],"D":[0,3,11],"E":[20,31,32,33],"C":[1,6,7,17]},"50":{"D":[19,29,30],"B":[0,3,10,11],"F":[17,24,25,26]},"51":{"H":[30,31],"B":[0,2,8,9],"E":[16,21,22,35]},"52":{"H":[2,8],"D":[24,25,26],"A":[9,10,18],"B":[0,5,14,15],"G":[7,17,22,23]},"53":{"H":[4,13],"D":[30,31,32],"E":[18,25,26,27],"F":[12,19,28,29],"C":[5,14,15,20]},"54":{"H":[2,8],"D":[24,25,26],"D_2":[27,28,29],"A":[5,14,15],"F":[11,19,30,31]},"55":{"H":[6,16],"A":[4,12,13],"F":[0,1,3,10]},"56":{"B":[6,16,21,35],"C":[0,4,5,15]},"57":{"H":[30,31],"H_2":[5,15],"D":[24,25,26],"C":[3,10,11,18]},"58":{"D":[0,2,8],"D_2":[21,22,23],"C":[1,6,7,17]},"59":{"H":[33,34],"F":[11,19,30,31],"G":[8,17,24,25]},"60":{"H":[30,31],"E":[0,1,4,7],"C":[2,8,9,17]},"61":{"D":[0,1,7],"G":[3,11,12,19]},"62":{"A":[9,10,18],"C":[5,14,20,33]},"63":{"H":[33,34],"H_2":[30,31],"D":[0,1,6]},"64":{"A":[10,18,27],"A_2":[1,6,7],"B":[0,4,12,13]},"65":{"B":[0,5,14,15],"E":[17,22,23,24],"G":[11,19,28,29]},"66":{"H":[28,29],"A":[4,12,13],"G":[0,1,2,7]},"67":{"D":[27,28,29],"D_2":[0,2,9],"C":[4,12,19,30]},"68":{"H":[27,28],"A":[3,10,11],"E":[20,32,33,34]},"69":{"B":[8,17,23,24],"C":[0,4,5,12]},"70":{"A":[12,19,30],"E":[0,2,4,8]},"71":{"A":[7,8,17],"F":[0,2,4,12]},"72":{"D":[24,25,26],"A":[4,12,13],"A_2":[9,10,18],"B":[15,16,21,35]},"73":{"D":[24,25,26],"G":[3,11,12,19],"E":[16,21,34,35]},"74":{"A_2":[5,14,15],"B":[10,18,26,27],"D_2":[0,3,11]},"75":{"F":[0,1,3,10],"B":[6,16,21,35],"A_2":[2,8,9]},"76":{"D_2":[30,31,32],"D":[16,21,35],"A_2":[2,8,9],"H":[25,26]},"77":{"E":[0,2,4,8],"A_2":[5,14,15],"G":[13,20,31,32],"C":[1,6,16,21]},"78":{"A_2":[4,12,13],"H":[14,20],"D_2":[27,28,29]},"79":{"A":[2,8,9],"D":[30,31,32],"F":[10,18,25,26]},"80":{"A_2":[9,10,18],"C":[5,14,20,33],"D":[27,28,29]},"81":{"A":[2,8,9],"A_2":[5,14,15],"D_2":[0,1,7]},"82":{"B":[0,5,14,15],"D_2":[27,28,29],"G":[7,17,22,23]},"83":{"A":[5,14,15],"D_2":[0,1,7],"F":[10,18,25,26]},"84":{"H_2":[31,32],"A":[2,8,9],"E":[0,1,3,11]},"85":{"D":[0,2,9],"B":[8,17,23,24],"C":[4,12,19,30]},"86":{"E":[0,2,4,13],"D_2":[30,31,32],"H_2":[21,22],"C":[5,14,15,20]},"87":{"D_2":[33,34,35],"H_2":[4,12],"H":[30,31]},"88":{"G":[0,4,5,14],"C":[3,10,11,18],"H_2":[12,19],"E":[17,22,23,24]},"89":{"B":[6,16,21,35],"H":[28,29],"D":[24,25,26]},"90":{"A":[10,18,27],"G":[15,16,34,35],"A_2":[1,6,7]},"91":{"A_2":[5,14,15],"F":[13,20,33,34],"A":[3,10,11],"D_2":[27,28,29]},"92":{"A":[1,6,7],"H_2":[17,23],"D":[27,28,29]},"93":{"H":[24,25],"G":[15,16,34,35],"E":[18,26,27,28]},"94":{"B":[7,17,23,24],"D_2":[0,1,6],"A_2":[5,14,15]},"95":{"C":[4,12,13,20],"D_2":[33,34,35],"F":[15,16,21,22]},"96":{"F":[6,16,34,35],"E":[20,31,32,33],"H_2":[4,13],"C":[0,2,3,11]},"97":{"E":[20,31,32,33],"D_2":[21,22,23],"D":[24,25,26]},"98":{"D_2":[13,20,33],"D":[27,28,29],"H_2":[31,32]},"99":{"D_2":[33,34,35],"E":[18,25,26,27],"H_2":[3,10]},"100":{"A_2":[2,8,9],"D":[21,22,23],"E":[18,26,27,28]},"101":{"H":[34,35],"D_2":[0,3,11]},"102":{"F":[14,20,31,32],"A_2":[4,12,13]},"103":{"H_2":[28,29],"B":[10,18,26,27]},"104":{"C":[1,6,7,17],"G":[14,20,33,34],"A_2":[4,12,13]},"105":{"G":[7,17,22,23],"D_2":[0,1,6],"B":[14,20,32,33]},"106":{"D":[0,4,12],"C":[1,6,7,16],"H_2":[21,22]},"107":{"B":[12,19,29,30],"A_2":[5,14,15]},"108":{"F":[17,21,22,23],"G":[13,20,31,32],"A":[2,8,9]},"109":{"A":[1,6,7],"D_2":[33,34,35],"E":[19,28,29,30]},"110":{"G":[13,20,31,32],"A":[2,8,9],"H":[28,29]},"111":{"D":[12,19,29],"F":[13,20,33,34],"D_2":[30,31,32]},"112":{"A_2":[1,6,7],"A":[11,12,19]},"113":{"E":[19,28,29,30],"G":[13,20,31,32],"H":[25,26]},"114":{"A":[5,14,15],"B":[8,17,23,24],"D":[0,2,9]},"115":{"H":[27,28],"C":[2,8,9,18]},"116":{"B":[0,1,6,7],"A_2":[14,20,33],"E":[16,21,34,35]},"117":{"A":[1,6,7],"B":[9,18,26,27]},"118":{"D":[14,20,32],"C":[1,6,7,16]},"119":{"G":[13,20,31,32],"H":[25,26]},"120":{"F":[4,13,20,33],"D":[24,25,26]}};
    </script>
    <script>
    (function() {
        'use strict';
        
        const SVG_NS = 'http://www.w3.org/2000/svg';
        const CX = 275;
        const CY = 250;
        const FICHA_RADIUS = 28;
        const LIGHT_ANGLE_RAD = (-135) * Math.PI / 180;
        
        // Board area bounds (for snap detection)
        const BOARD_BOTTOM = 520;
        
        const boardCells = {};
        const pieces = [];
        let selectedPieceIndex = null;
        let rotationDirection = 1; // 1 = derecha (clockwise), -1 = izquierda
        let dragging = null;
        let dragOffset = { x: 0, y: 0 };
        
        function svg(tag, attrs) {
            const el = document.createElementNS(SVG_NS, tag);
            Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
            return el;
        }
        
        function getVertices(cx, cy, r, rotationDeg) {
            return [0,1,2,3,4].map(i => {
                const angle = (rotationDeg + i * 72) * Math.PI / 180;
                return {
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle)
                };
            });
        }
        
        function pentaPoints(cx, cy, r, rotationDeg) {
            return getVertices(cx, cy, r, rotationDeg).map(v => `${v.x},${v.y}`).join(' ');
        }
        
        function getAdjacentPosition(centerX, centerY, centerRotation, sideIndex, radius) {
            const vertices = getVertices(centerX, centerY, radius, centerRotation);
            const v1 = vertices[sideIndex];
            const v2 = vertices[(sideIndex + 1) % 5];
            const midX = (v1.x + v2.x) / 2;
            const midY = (v1.y + v2.y) / 2;
            const dx = midX - centerX;
            const dy = midY - centerY;
            return { 
                x: midX + dx, 
                y: midY + dy, 
                rotation: centerRotation + 180 
            };
        }
        
        function getExpectedAdjacentDistance() {
            const apothem = FICHA_RADIUS * Math.cos(36 * Math.PI / 180);
            return apothem * 2;
        }
        
        function getDistance(f1, f2) {
            return Math.sqrt((f1.x - f2.x) ** 2 + (f1.y - f2.y) ** 2);
        }
        
        function findSidePointingTo(ficha, targetX, targetY) {
            let closestSide = 0;
            let closestDist = Infinity;
            for (let side = 0; side < 5; side++) {
                const adj = getAdjacentPosition(ficha.x, ficha.y, ficha.rotation, side, FICHA_RADIUS);
                const dist = Math.sqrt((adj.x - targetX) ** 2 + (adj.y - targetY) ** 2);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestSide = side;
                }
            }
            return closestSide;
        }
        
        function findPositionTouchingBoth(fichaA, fichaB) {
            const expectedDist = getExpectedAdjacentDistance();
            const tolerance = 2;
            for (let sideA = 0; sideA < 5; sideA++) {
                const posFromA = getAdjacentPosition(fichaA.x, fichaA.y, fichaA.rotation, sideA, FICHA_RADIUS);
                const distToB = getDistance(posFromA, fichaB);
                if (Math.abs(distToB - expectedDist) < tolerance) {
                    return posFromA;
                }
            }
            return null;
        }
        
        function findFreeAdjacentPositionToward(ficha, targetX, targetY, existingFichas) {
            const expectedDist = getExpectedAdjacentDistance();
            const candidates = [];
            for (let side = 0; side < 5; side++) {
                const testPos = getAdjacentPosition(ficha.x, ficha.y, ficha.rotation, side, FICHA_RADIUS);
                let collides = false;
                for (const id of Object.keys(existingFichas)) {
                    const dist = getDistance(testPos, existingFichas[id]);
                    if (dist < expectedDist - 1) {
                        collides = true;
                        break;
                    }
                }
                if (!collides) {
                    const distToTarget = Math.sqrt((testPos.x - targetX) ** 2 + (testPos.y - targetY) ** 2);
                    candidates.push({ pos: testPos, distToTarget });
                }
            }
            candidates.sort((a, b) => a.distToTarget - b.distToTarget);
            return candidates.length > 0 ? candidates[0].pos : null;
        }
        
        function getFaceBrightness(faceNormalAngleDeg) {
            const normalRad = faceNormalAngleDeg * Math.PI / 180;
            const dot = Math.cos(LIGHT_ANGLE_RAD - normalRad);
            return Math.max(0.20, Math.min(0.98, 0.55 - dot * 0.40));
        }
        
        function brightnessToColor(brightness) {
            const val = Math.round(brightness * 255);
            return `rgb(${val}, ${val}, ${Math.round(val * 0.98)})`;
        }
        
        // Create board hole
        function createBoardHole(cx, cy, rotationDeg, id) {
            const g = svg('g', { class: 'board-hole', 'data-id': id });
            
            const border = svg('polygon', {
                points: pentaPoints(cx, cy, FICHA_RADIUS + 3.5, rotationDeg),
                fill: '#333333'
            });
            g.appendChild(border);
            
            const outerVerts = getVertices(cx, cy, FICHA_RADIUS, rotationDeg);
            
            // White pentagon base
            g.appendChild(svg('polygon', {
                points: outerVerts.map(v => `${v.x},${v.y}`).join(' '),
                fill: '#ffffff'
            }));
            
            // Light gray radial lines
            outerVerts.forEach(v => {
                g.appendChild(svg('line', {
                    x1: cx, y1: cy, x2: v.x, y2: v.y,
                    stroke: '#cccccc', 'stroke-width': '0.8'
                }));
            });
            
            g.appendChild(svg('circle', { cx, cy, r: 2, fill: '#cccccc' }));
            
            return g;
        }
        
        // Create crystal cell for pieces
        function createCrystalCell(cx, cy, rotationDeg, gradientId) {
            const g = svg('g', { class: 'crystal-cell' });
            const verts = getVertices(cx, cy, FICHA_RADIUS, rotationDeg);
            const points = verts.map(v => `${v.x},${v.y}`).join(' ');
            
            // Shadow
            g.appendChild(svg('polygon', {
                points: getVertices(cx + 1, cy + 2, FICHA_RADIUS, rotationDeg).map(v => `${v.x},${v.y}`).join(' '),
                fill: 'rgba(0,0,0,0.3)'
            }));
            
            // Main body with thin dark outline
            g.appendChild(svg('polygon', { 
                points, 
                fill: `url(#${gradientId})`, 
                stroke: 'rgba(0,0,0,0.4)', 
                'stroke-width': '0.5' 
            }));
            
            // Shine overlay
            g.appendChild(svg('polygon', { 
                points, 
                fill: 'url(#crystalShine)', 
                opacity: '0.5' 
            }));
            
            // Facet lines
            verts.forEach(v => {
                g.appendChild(svg('line', { 
                    x1: cx, y1: cy, x2: v.x, y2: v.y, 
                    stroke: 'rgba(255,255,255,0.2)', 
                    'stroke-width': '0.5' 
                }));
            });
            
            // Sparkle
            g.appendChild(svg('ellipse', { 
                cx: cx - 5, cy: cy - 7, rx: 6, ry: 3, 
                fill: 'url(#sparkle)', 
                transform: `rotate(-20, ${cx - 5}, ${cy - 7})` 
            }));
            
            return g;
        }
        
        // ============ PIECE DEFINITIONS ============
        
        // H: Blue, 2 cells - simple pair
        function createPieceH_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: adjacent to cell 0 on side 2 (or 3 if flipped)
            const side = flipped ? 3 : 2;
            const adj = getAdjacentPosition(0, 0, baseRotation, side, FICHA_RADIUS);
            cells.push({ x: adj.x, y: adj.y, rotation: adj.rotation });
            
            return cells;
        }
        
        // A: Purple, 3 cells in V shape (like cells 2-8-9)
        // Anchor is at the vertex of V, two cells extend from adjacent sides
        function createPieceA_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin (vertex of V)
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: adjacent to anchor on side 0
            const side1 = flipped ? 4 : 0;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: adjacent to anchor on side 1 (forms V with cell 1)
            const side2 = flipped ? 3 : 1;
            const adj2 = getAdjacentPosition(0, 0, baseRotation, side2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            return cells;
        }
        
        // B: Lime, 4 cells in T shape (like cells 8-17-23-24)
        // Anchor (17) is center, cells on sides 0, 2, 4
        function createPieceB_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin (center of T)
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: side 0 (top-right of T)
            const side1 = flipped ? 4 : 0;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: side 2 (bottom/stem of T)
            const adj2 = getAdjacentPosition(0, 0, baseRotation, 2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            // Cell 3: side 4 (top-left of T)
            const side3 = flipped ? 0 : 4;
            const adj3 = getAdjacentPosition(0, 0, baseRotation, side3, FICHA_RADIUS);
            cells.push({ x: adj3.x, y: adj3.y, rotation: adj3.rotation });
            
            return cells;
        }
        
        // F: Green, 4 cells in arc/curve shape (like cells 9-18-27-28)
        function createPieceF_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin (like cell 9)
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: from cell 0, side 2 (like 9â†’18)
            const side1 = 2;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: from cell 1, side 0 (like 18â†’27) - curve starts here
            const side2 = flipped ? 4 : 0;
            const adj2 = getAdjacentPosition(adj1.x, adj1.y, adj1.rotation, side2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            // Cell 3: from cell 2, side 3 (like 27â†’28) - continues curve
            const side3 = flipped ? 1 : 3;
            const adj3 = getAdjacentPosition(adj2.x, adj2.y, adj2.rotation, side3, FICHA_RADIUS);
            cells.push({ x: adj3.x, y: adj3.y, rotation: adj3.rotation });
            
            return cells;
        }
        
        // E: Orange, 4 cells in straight line (like D but longer)
        function createPieceE_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: adjacent to cell 0
            const side1 = flipped ? 4 : 1;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: continues line
            const side2 = flipped ? 1 : 4;
            const adj2 = getAdjacentPosition(adj1.x, adj1.y, adj1.rotation, side2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            // Cell 3: continues line
            const side3 = flipped ? 4 : 1;
            const adj3 = getAdjacentPosition(adj2.x, adj2.y, adj2.rotation, side3, FICHA_RADIUS);
            cells.push({ x: adj3.x, y: adj3.y, rotation: adj3.rotation });
            
            return cells;
        }
        
        // C: Cyan, 4 cells in Y shape (like cells 4-12-19-30)
        // Anchor at 12, branches to 4 (side 0), 19 (side 2), then 19->30 (side 1)
        function createPieceC_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin (like cell 12)
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: from anchor, side 0 (like 12â†’4)
            const side1 = flipped ? 4 : 0;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: from anchor, side 2 (like 12â†’19)
            const adj2 = getAdjacentPosition(0, 0, baseRotation, 2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            // Cell 3: from cell 2, side 1 (like 19â†’30)
            const side3 = flipped ? 3 : 1;
            const adj3 = getAdjacentPosition(adj2.x, adj2.y, adj2.rotation, side3, FICHA_RADIUS);
            cells.push({ x: adj3.x, y: adj3.y, rotation: adj3.rotation });
            
            return cells;
        }
        
        // G: Yellow, 4 cells in compact Y shape (like cells 14-20-33-34)
        // Anchor at 20, branches to 14 (side 3), 33 (side 2), then 33->34 (side 0)
        function createPieceG_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin (like cell 20)
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: from anchor, side 3 (like 20â†’14)
            const side1 = flipped ? 1 : 3;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: from anchor, side 2 (like 20â†’33)
            const adj2 = getAdjacentPosition(0, 0, baseRotation, 2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            // Cell 3: from cell 2, side 0 (like 33â†’34)
            const side3 = flipped ? 4 : 0;
            const adj3 = getAdjacentPosition(adj2.x, adj2.y, adj2.rotation, side3, FICHA_RADIUS);
            cells.push({ x: adj3.x, y: adj3.y, rotation: adj3.rotation });
            
            return cells;
        }
        
        // D: Red, 3 cells in straight line (like cells 27-28-29)
        function createPieceD_cells(baseRotation, flipped) {
            const cells = [];
            
            // Cell 0: anchor at origin
            cells.push({ x: 0, y: 0, rotation: baseRotation });
            
            // Cell 1: adjacent to cell 0 on side 1 (or side 4 if flipped horizontally)
            const side1 = flipped ? 4 : 1;
            const adj1 = getAdjacentPosition(0, 0, baseRotation, side1, FICHA_RADIUS);
            cells.push({ x: adj1.x, y: adj1.y, rotation: adj1.rotation });
            
            // Cell 2: adjacent to cell 1, continuing the line
            const side2 = flipped ? 1 : 4;
            const adj2 = getAdjacentPosition(adj1.x, adj1.y, adj1.rotation, side2, FICHA_RADIUS);
            cells.push({ x: adj2.x, y: adj2.y, rotation: adj2.rotation });
            
            return cells;
        }
        
        // Calculate the outer contour of a piece (all cells combined)
        function getPieceOutline(cells) {
            // Collect all edges from all cells
            const allEdges = [];
            
            cells.forEach((cell, cellIndex) => {
                const verts = getVertices(cell.x, cell.y, FICHA_RADIUS, cell.rotation);
                for (let i = 0; i < 5; i++) {
                    const v1 = verts[i];
                    const v2 = verts[(i + 1) % 5];
                    // Create edge with sorted key for comparison
                    const key = `${Math.round(v1.x*10)},${Math.round(v1.y*10)}-${Math.round(v2.x*10)},${Math.round(v2.y*10)}`;
                    const reverseKey = `${Math.round(v2.x*10)},${Math.round(v2.y*10)}-${Math.round(v1.x*10)},${Math.round(v1.y*10)}`;
                    allEdges.push({ v1, v2, key, reverseKey });
                }
            });
            
            // Find edges that appear only once (exterior edges)
            // Shared edges between cells appear twice (once in each direction)
            const edgeCount = {};
            allEdges.forEach(edge => {
                const normalizedKey = edge.key < edge.reverseKey ? edge.key : edge.reverseKey;
                edgeCount[normalizedKey] = (edgeCount[normalizedKey] || 0) + 1;
            });
            
            const exteriorEdges = allEdges.filter(edge => {
                const normalizedKey = edge.key < edge.reverseKey ? edge.key : edge.reverseKey;
                return edgeCount[normalizedKey] === 1;
            });
            
            if (exteriorEdges.length === 0) return '';
            
            // Build path by connecting edges
            const path = [exteriorEdges[0].v1, exteriorEdges[0].v2];
            const used = new Set([0]);
            
            while (used.size < exteriorEdges.length) {
                const lastPoint = path[path.length - 1];
                let found = false;
                
                for (let i = 0; i < exteriorEdges.length; i++) {
                    if (used.has(i)) continue;
                    const edge = exteriorEdges[i];
                    
                    const d1 = Math.abs(edge.v1.x - lastPoint.x) + Math.abs(edge.v1.y - lastPoint.y);
                    const d2 = Math.abs(edge.v2.x - lastPoint.x) + Math.abs(edge.v2.y - lastPoint.y);
                    
                    if (d1 < 0.5) {
                        path.push(edge.v2);
                        used.add(i);
                        found = true;
                        break;
                    } else if (d2 < 0.5) {
                        path.push(edge.v1);
                        used.add(i);
                        found = true;
                        break;
                    }
                }
                
                if (!found) break;
            }
            
            return path.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x},${p.y}`).join(' ') + ' Z';
        }
        
        // Create indicator icon for movable piece (small dot)
        function createMoveIndicator(cells) {
            // Find furthest cell from anchor
            let furthestCell = cells[0];
            let maxDist = 0;
            cells.forEach(cell => {
                const dist = Math.sqrt(cell.x * cell.x + cell.y * cell.y);
                if (dist > maxDist) {
                    maxDist = dist;
                    furthestCell = cell;
                }
            });
            
            const indicator = svg('g', { class: 'move-indicator' });
            const iconX = furthestCell.x;
            const iconY = furthestCell.y;
            
            // Simple circle indicator
            indicator.appendChild(svg('circle', {
                cx: iconX, cy: iconY, r: 5,
                fill: 'rgba(0,0,0,0.6)',
                stroke: '#fff',
                'stroke-width': '1'
            }));
            
            // Inner dot
            indicator.appendChild(svg('circle', {
                cx: iconX, cy: iconY, r: 2,
                fill: '#fff'
            }));
            
            return indicator;
        }
        
        // Generic piece creation
        function createPiece(type, id, startX, startY, rotation, flipped) {
            let cells;
            let gradient;
            
            switch(type) {
                case 'H':
                    cells = createPieceH_cells(rotation, flipped);
                    gradient = 'crystalBlue';
                    break;
                case 'D':
                    cells = createPieceD_cells(rotation, flipped);
                    gradient = 'crystalRed';
                    break;
                case 'A':
                    cells = createPieceA_cells(rotation, flipped);
                    gradient = 'crystalPurple';
                    break;
                case 'B':
                    cells = createPieceB_cells(rotation, flipped);
                    gradient = 'crystalLime';
                    break;
                case 'E':
                    cells = createPieceE_cells(rotation, flipped);
                    gradient = 'crystalOrange';
                    break;
                case 'C':
                    cells = createPieceC_cells(rotation, flipped);
                    gradient = 'crystalCyan';
                    break;
                case 'G':
                    cells = createPieceG_cells(rotation, flipped);
                    gradient = 'crystalYellow';
                    break;
                case 'F':
                    cells = createPieceF_cells(rotation, flipped);
                    gradient = 'crystalGreen';
                    break;
                default:
                    cells = [];
                    gradient = 'crystalBlue';
            }
            
            const g = svg('g', { 
                class: 'piece', 
                'data-id': id,
                style: 'cursor: grab;'
            });
            
            // Selection highlight (hidden by default) - follows piece contour
            const outlinePath = getPieceOutline(cells);
            // White stroke with dark outline for visibility on all colors
            const highlightBg = svg('path', {
                class: 'selection-highlight-bg',
                d: outlinePath,
                fill: 'none',
                stroke: '#000000',
                'stroke-width': '5',
                'stroke-linejoin': 'round',
                opacity: '0'
            });
            g.appendChild(highlightBg);
            const highlight = svg('path', {
                class: 'selection-highlight',
                d: outlinePath,
                fill: 'none',
                stroke: '#ffffff',
                'stroke-width': '3',
                'stroke-linejoin': 'round',
                opacity: '0'
            });
            g.appendChild(highlight);
            
            cells.forEach(cell => {
                g.appendChild(createCrystalCell(cell.x, cell.y, cell.rotation, gradient));
            });
            
            // Add rotation icon at the furthest cell from anchor
            g.appendChild(createMoveIndicator(cells));
            
            g.setAttribute('transform', `translate(${startX}, ${startY})`);
            
            return {
                element: g,
                id: id,
                type: type,
                x: startX,
                y: startY,
                rotation: rotation,
                flipped: flipped,
                flippedV: false,
                flippedH: false,
                cells: cells,
                snappedTo: null,
                startX: startX,
                startY: startY
            };
        }
        
        function updateSelectionHighlight() {
            pieces.forEach((piece, idx) => {
                const highlight = piece.element.querySelector('.selection-highlight');
                const highlightBg = piece.element.querySelector('.selection-highlight-bg');
                const isSelected = idx === selectedPieceIndex;
                if (highlight) highlight.setAttribute('opacity', isSelected ? '1' : '0');
                if (highlightBg) highlightBg.setAttribute('opacity', isSelected ? '1' : '0');
            });
        }
        
        function rebuildPiece(piece, useIntroColor = false) {
            let cells;
            let gradient;
            
            if (useIntroColor) {
                gradient = 'crystalSilver';
            } else {
                switch(piece.type) {
                    case 'H': gradient = 'crystalBlue'; break;
                    case 'D': gradient = 'crystalRed'; break;
                    case 'A': gradient = 'crystalPurple'; break;
                    case 'B': gradient = 'crystalLime'; break;
                    case 'E': gradient = 'crystalOrange'; break;
                    case 'C': gradient = 'crystalCyan'; break;
                    case 'G': gradient = 'crystalYellow'; break;
                    case 'F': gradient = 'crystalGreen'; break;
                    default: gradient = 'crystalSilver';
                }
            }
            
            switch(piece.type) {
                case 'H':
                    cells = createPieceH_cells(piece.rotation, piece.flipped);
                    break;
                case 'D':
                    cells = createPieceD_cells(piece.rotation, piece.flipped);
                    break;
                case 'A':
                    cells = createPieceA_cells(piece.rotation, piece.flipped);
                    break;
                case 'B':
                    cells = createPieceB_cells(piece.rotation, piece.flipped);
                    break;
                case 'E':
                    cells = createPieceE_cells(piece.rotation, piece.flipped);
                    break;
                case 'C':
                    cells = createPieceC_cells(piece.rotation, piece.flipped);
                    break;
                case 'G':
                    cells = createPieceG_cells(piece.rotation, piece.flipped);
                    break;
                case 'F':
                    cells = createPieceF_cells(piece.rotation, piece.flipped);
                    break;
                default:
                    cells = [];
            }
            
            // Apply horizontal flip if needed (mirror across X axis - Invertir H)
            if (piece.flippedV) {
                cells = cells.map(cell => ({
                    x: cell.x,
                    y: -cell.y,
                    rotation: cell.rotation
                }));
            }
            
            // Apply vertical flip if needed (mirror across Y axis - Invertir V)
            if (piece.flippedH) {
                cells = cells.map(cell => ({
                    x: -cell.x,
                    y: cell.y,
                    rotation: cell.rotation
                }));
            }
            
            piece.cells = cells;
            
            // For visual rendering, create cells with visual rotations
            let visualCells = cells.map(cell => ({ ...cell }));
            if (piece.flippedV) {
                visualCells = visualCells.map(cell => ({ x: cell.x, y: cell.y, rotation: -cell.rotation }));
            }
            if (piece.flippedH) {
                visualCells = visualCells.map(cell => ({ x: cell.x, y: cell.y, rotation: 180 - cell.rotation }));
            }
            
            const g = svg('g', { 
                class: 'piece', 
                'data-id': piece.id,
                style: piece.isPreplaced ? 'cursor: default; opacity: 0.85;' : 'cursor: grab;'
            });
            
            // Selection highlight - follows piece contour (use visual cells)
            const outlinePath = getPieceOutline(visualCells);
            
            // Permanent black outline for piece silhouette
            const blackOutline = svg('path', {
                class: 'piece-outline',
                d: outlinePath,
                fill: 'none',
                stroke: '#000000',
                'stroke-width': '2',
                'stroke-linejoin': 'round',
                opacity: '1'
            });
            g.appendChild(blackOutline);
            
            const highlightBg = svg('path', {
                class: 'selection-highlight-bg',
                d: outlinePath,
                fill: 'none',
                stroke: '#000000',
                'stroke-width': '5',
                'stroke-linejoin': 'round',
                opacity: selectedPieceIndex === piece.id ? '1' : '0'
            });
            g.appendChild(highlightBg);
            const highlight = svg('path', {
                class: 'selection-highlight',
                d: outlinePath,
                fill: 'none',
                stroke: '#ffffff',
                'stroke-width': '3',
                'stroke-linejoin': 'round',
                opacity: selectedPieceIndex === piece.id ? '1' : '0'
            });
            g.appendChild(highlight);
            
            visualCells.forEach(cell => {
                g.appendChild(createCrystalCell(cell.x, cell.y, cell.rotation, gradient));
            });
            
            // Add rotation icon only if not preplaced
            if (!piece.isPreplaced) {
                g.appendChild(createMoveIndicator(visualCells));
            }
            
            g.setAttribute('transform', `translate(${piece.x}, ${piece.y})`);
            
            const piecesGroup = document.getElementById('pieces-group');
            piecesGroup.replaceChild(g, piece.element);
            piece.element = g;
        }
        
        // ============ BOARD BUILDING ============
        
        function buildBoard(group) {
            const boardRadius = 238;
            const boardCenterY = CY + 5;
            const outerRadius = boardRadius + 6;
            
            const outerPoints = [0,1,2,3,4].map(i => {
                const angle = (-90 + i * 72) * Math.PI / 180;
                return `${CX + outerRadius * Math.cos(angle)},${boardCenterY + outerRadius * Math.sin(angle)}`;
            }).join(' ');
            
            const innerPoints = [0,1,2,3,4].map(i => {
                const angle = (-90 + i * 72) * Math.PI / 180;
                return `${CX + boardRadius * Math.cos(angle)},${boardCenterY + boardRadius * Math.sin(angle)}`;
            }).join(' ');
            
            group.appendChild(svg('polygon', { points: outerPoints, fill: '#1a1a20', stroke: '#0a0a0f', 'stroke-width': '2' }));
            group.appendChild(svg('polygon', { points: innerPoints, fill: 'url(#boardGradient)', stroke: '#2a2a30', 'stroke-width': '1' }));
            
            // Build all 36 cells
            const centerRotation = 90;
            addBoardCell(CX, CY, centerRotation, 0, group);
            
            for (let i = 0; i < 5; i++) {
                const adj = getAdjacentPosition(CX, CY, centerRotation, i, FICHA_RADIUS);
                addBoardCell(adj.x, adj.y, adj.rotation, i + 1, group);
            }
            
            let nextId = 6;
            for (let i = 1; i <= 5; i++) {
                const ficha = boardCells[i];
                const sideToCenter = findSidePointingTo(ficha, CX, CY);
                const extSide1 = (sideToCenter + 2) % 5;
                const extSide2 = (sideToCenter + 3) % 5;
                for (const side of [extSide1, extSide2]) {
                    const newPos = getAdjacentPosition(ficha.x, ficha.y, ficha.rotation, side, FICHA_RADIUS);
                    addBoardCell(newPos.x, newPos.y, newPos.rotation, nextId++, group);
                }
            }
            
            const pairs = [[6, 15], [7, 8], [9, 10], [11, 12], [13, 14]];
            for (const [idA, idB] of pairs) {
                const newPos = findPositionTouchingBoth(boardCells[idA], boardCells[idB]);
                if (newPos) addBoardCell(newPos.x, newPos.y, newPos.rotation, nextId++, group);
            }
            
            const arcs = [[16, 17], [17, 18], [18, 19], [19, 20], [20, 16]];
            for (const [startId, endId] of arcs) {
                nextId = buildArc(startId, endId, nextId, group);
            }
        }
        
        function addBoardCell(x, y, rotation, id, group) {
            boardCells[id] = { x, y, rotation };
            group.appendChild(createBoardHole(x, y, rotation, id));
        }
        
        function buildArc(startId, endId, startFichaId, group) {
            const startFicha = boardCells[startId];
            const endFicha = boardCells[endId];
            let nextId = startFichaId;
            
            const pos1 = findFreeAdjacentPositionToward(startFicha, endFicha.x, endFicha.y, boardCells);
            if (pos1) addBoardCell(pos1.x, pos1.y, pos1.rotation, nextId++, group);
            
            const ficha1 = boardCells[nextId - 1];
            if (ficha1) {
                const pos2 = findFreeAdjacentPositionToward(ficha1, endFicha.x, endFicha.y, boardCells);
                if (pos2) addBoardCell(pos2.x, pos2.y, pos2.rotation, nextId++, group);
            }
            
            const ficha2 = boardCells[nextId - 1];
            if (ficha2) {
                const pos3 = findPositionTouchingBoth(ficha2, endFicha);
                if (pos3) addBoardCell(pos3.x, pos3.y, pos3.rotation, nextId++, group);
            }
            
            return nextId;
        }
        
        // ============ INTERACTION ============
        
        // Intro mode flag
        let introMode = true;
        
        function init() {
            const boardGroup = document.getElementById('board-group');
            const piecesGroup = document.getElementById('pieces-group');
            
            buildBoard(boardGroup);
            
            // Create all 11 pieces starting OUTSIDE the visible area (for intro animation)
            // They will fly in from different directions
            const startPositions = [
                { x: -100, y: 100 },   // H - from left
                { x: 650, y: 100 },    // H_2 - from right
                { x: -100, y: 300 },   // D - from left
                { x: 650, y: 300 },    // D_2 - from right
                { x: 275, y: -100 },   // A - from top
                { x: 275, y: 900 },    // A_2 - from bottom
                { x: -100, y: 500 },   // B - from left
                { x: 650, y: 500 },    // E - from right
                { x: 100, y: -100 },   // F - from top
                { x: 450, y: -100 },   // C - from top
                { x: 275, y: 900 }     // G - from bottom
            ];
            
            pieces.push(createPiece('H', 0, startPositions[0].x, startPositions[0].y, 90, false));
            pieces.push(createPiece('H', 1, startPositions[1].x, startPositions[1].y, 90, false));
            pieces.push(createPiece('D', 2, startPositions[2].x, startPositions[2].y, 90, false));
            pieces.push(createPiece('D', 3, startPositions[3].x, startPositions[3].y, 90, false));
            pieces.push(createPiece('A', 4, startPositions[4].x, startPositions[4].y, 270, false));
            pieces.push(createPiece('A', 5, startPositions[5].x, startPositions[5].y, 270, false));
            pieces.push(createPiece('B', 6, startPositions[6].x, startPositions[6].y, 270, false));
            pieces.push(createPiece('E', 7, startPositions[7].x, startPositions[7].y, 90, false));
            pieces.push(createPiece('F', 8, startPositions[8].x, startPositions[8].y, 90, false));
            pieces.push(createPiece('C', 9, startPositions[9].x, startPositions[9].y, 90, false));
            pieces.push(createPiece('G', 10, startPositions[10].x, startPositions[10].y, 270, false));
            
            pieces.forEach(p => piecesGroup.appendChild(p.element));
            
            // Calculate optimal positions for pieces in the waiting area
            // Area bounds: x=10-540, y=590-810 (inside the rectangle)
            // Each piece needs space based on its cells extent
            const AREA_LEFT = 45;
            const AREA_RIGHT = 505;
            const AREA_TOP = 615;
            const AREA_BOTTOM = 795;
            
            // Piece sizes (approximate max extent from anchor in any direction)
            // H: 2 cells horizontal ~60px wide
            // D: 3 cells L-shape ~85px wide, ~55px tall
            // A: 3 cells L-shape ~60px wide, ~55px tall  
            // B: 4 cells ~85px wide, ~55px tall
            // E: 4 cells ~110px wide
            // F: 4 cells ~85px wide, ~80px tall
            // C: 4 cells ~85px wide, ~55px tall
            // G: 4 cells ~85px wide, ~55px tall
            
            // Row 1: H(0), H(1), D(2), D(3) - y=620
            // Row 2: A(4), A(5), B(6), E(7) - y=700
            // Row 3: F(8), C(9), G(10) - y=780
            
            const row1Y = 575, row2Y = 660, row3Y = 745;
            
            // Distribute evenly with margins
            pieces[0].startX = 70;   pieces[0].startY = row1Y;  // H
            pieces[1].startX = 175;  pieces[1].startY = row1Y;  // H
            pieces[2].startX = 310;  pieces[2].startY = row1Y;  // D
            pieces[3].startX = 450;  pieces[3].startY = row1Y;  // D
            
            pieces[4].startX = 70;   pieces[4].startY = row2Y;  // A
            pieces[5].startX = 175;  pieces[5].startY = row2Y;  // A
            pieces[6].startX = 300;  pieces[6].startY = row2Y;  // B
            pieces[7].startX = 450;  pieces[7].startY = row2Y;  // E
            
            pieces[8].startX = 100;  pieces[8].startY = row3Y;  // F
            pieces[9].startX = 275;  pieces[9].startY = row3Y;  // C
            pieces[10].startX = 450; pieces[10].startY = row3Y; // G
            
            setupInteraction();
        }
        
        // Get the bounding box of a piece's cells
        function getPieceBounds(piece) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (const cell of piece.cells) {
                const cx = cell.x;
                const cy = cell.y;
                // Each cell is a pentagon with radius FICHA_RADIUS
                minX = Math.min(minX, cx - FICHA_RADIUS);
                maxX = Math.max(maxX, cx + FICHA_RADIUS);
                minY = Math.min(minY, cy - FICHA_RADIUS);
                maxY = Math.max(maxY, cy + FICHA_RADIUS);
            }
            
            return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY };
        }
        
        // Clamp piece position to stay within bounds
        function clampPiecePosition(piece, areaLeft, areaRight, areaTop, areaBottom) {
            const bounds = getPieceBounds(piece);
            
            let x = piece.x;
            let y = piece.y;
            
            // Check if piece extends beyond area
            if (x + bounds.minX < areaLeft) x = areaLeft - bounds.minX;
            if (x + bounds.maxX > areaRight) x = areaRight - bounds.maxX;
            if (y + bounds.minY < areaTop) y = areaTop - bounds.minY;
            if (y + bounds.maxY > areaBottom) y = areaBottom - bounds.maxY;
            
            return { x, y };
        }
        
        // Animate a piece from current position to target position
        function animatePieceTo(piece, targetX, targetY, targetRotation, targetFlipped, targetFlippedV, targetFlippedH, duration, delay, useIntroColor = true) {
            return new Promise(resolve => {
                setTimeout(() => {
                    const startX = piece.x;
                    const startY = piece.y;
                    const startTime = performance.now();
                    
                    // Set target state
                    piece.rotation = targetRotation;
                    piece.flipped = targetFlipped;
                    piece.flippedV = targetFlippedV;
                    piece.flippedH = targetFlippedH;
                    rebuildPiece(piece, useIntroColor);
                    
                    function animate(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Easing function (ease-out cubic)
                        const eased = 1 - Math.pow(1 - progress, 3);
                        
                        piece.x = startX + (targetX - startX) * eased;
                        piece.y = startY + (targetY - startY) * eased;
                        piece.element.setAttribute('transform', `translate(${piece.x}, ${piece.y})`);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            piece.x = targetX;
                            piece.y = targetY;
                            piece.element.setAttribute('transform', `translate(${targetX}, ${targetY})`);
                            resolve();
                        }
                    }
                    
                    requestAnimationFrame(animate);
                }, delay);
            });
        }
        
        // Play intro animation - pieces fly to form a random solution
        async function playIntro() {
            introMode = true;
            
            // Hide pieces area during intro
            document.querySelector('rect[y="510"]').setAttribute('opacity', '0');
            document.querySelector('rect[y="515"]').setAttribute('opacity', '0');
            document.querySelector('text[y="535"]').setAttribute('opacity', '0');
            
            // Pick a random solution
            const solutionKeys = Object.keys(SOLUCIONES);
            const randomKey = solutionKeys[Math.floor(Math.random() * solutionKeys.length)];
            const solution = SOLUCIONES[randomKey];
            
            const pieceMap = {
                'H': 0, 'H_2': 1, 'D': 2, 'D_2': 3,
                'A': 4, 'A_2': 5, 'B': 6, 'E': 7, 'F': 8, 'C': 9, 'G': 10
            };
            
            // Rebuild all pieces in silver color
            pieces.forEach(p => rebuildPiece(p, true));
            
            // Animate each piece to its solution position with staggered timing
            const animations = [];
            let delay = 100;
            
            for (const key of Object.keys(solution)) {
                const pieceIdx = pieceMap[key];
                if (pieceIdx === undefined) continue;
                
                const piece = pieces[pieceIdx];
                const targetCells = solution[key];
                
                // Find the configuration that places this piece at targetCells
                const config = findPieceConfigForCells(piece.type, targetCells);
                if (config) {
                    animations.push(
                        animatePieceTo(piece, config.x, config.y, config.rotation, config.flipped, config.flippedV, config.flippedH, 800, delay, true)
                    );
                    piece.snappedTo = targetCells.map(String);
                    delay += 150; // Stagger each piece
                }
            }
            
            await Promise.all(animations);
            
            // Update info text
            document.getElementById('game-info').textContent = 'Selecciona un nivel y reto para comenzar';
        }
        
        // Find piece configuration that places it at specific board cells
        function findPieceConfigForCells(type, targetCells) {
            const sortedTarget = targetCells.slice().sort((a, b) => a - b);
            const rotations = [90, 162, 234, 306, 18];
            const flipOptions = [false, true];
            
            function getCellsForType(type, rotation, flipped) {
                switch(type) {
                    case 'H': return createPieceH_cells(rotation, flipped);
                    case 'D': return createPieceD_cells(rotation, flipped);
                    case 'A': return createPieceA_cells(rotation, flipped);
                    case 'B': return createPieceB_cells(rotation, flipped);
                    case 'E': return createPieceE_cells(rotation, flipped);
                    case 'C': return createPieceC_cells(rotation, flipped);
                    case 'G': return createPieceG_cells(rotation, flipped);
                    case 'F': return createPieceF_cells(rotation, flipped);
                    default: return [];
                }
            }
            
            function applyFlips(cells, flippedV, flippedH) {
                let result = cells;
                if (flippedV) result = result.map(c => ({ x: c.x, y: -c.y, rotation: c.rotation }));
                if (flippedH) result = result.map(c => ({ x: -c.x, y: c.y, rotation: c.rotation }));
                return result;
            }
            
            function findMatchingBoardCells(pieceCells, pieceX, pieceY) {
                const matched = [];
                for (const cell of pieceCells) {
                    const worldX = pieceX + cell.x;
                    const worldY = pieceY + cell.y;
                    let closestId = null, closestDist = Infinity;
                    for (const [id, bc] of Object.entries(boardCells)) {
                        const dist = Math.sqrt((bc.x - worldX) ** 2 + (bc.y - worldY) ** 2);
                        if (dist < closestDist) { closestDist = dist; closestId = id; }
                    }
                    if (closestDist < 5) matched.push(parseInt(closestId));
                }
                return matched.sort((a, b) => a - b);
            }
            
            for (const rotation of rotations) {
                for (const flipped of flipOptions) {
                    for (const flippedV of flipOptions) {
                        for (const flippedH of flipOptions) {
                            const baseCells = getCellsForType(type, rotation, flipped);
                            const cells = applyFlips(baseCells, flippedV, flippedH);
                            
                            for (const anchor of sortedTarget) {
                                const bc = boardCells[anchor];
                                if (!bc) continue;
                                const px = bc.x - cells[0].x;
                                const py = bc.y - cells[0].y;
                                const matched = findMatchingBoardCells(cells, px, py);
                                
                                if (matched.length === sortedTarget.length && 
                                    matched.every((v, i) => v === sortedTarget[i])) {
                                    return { x: px, y: py, rotation, flipped, flippedV, flippedH };
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }
        
        function setupInteraction() {
            const svgEl = document.getElementById('game-svg');
            
            function getMousePos(evt) {
                const CTM = svgEl.getScreenCTM();
                const pt = svgEl.createSVGPoint();
                const touch = evt.touches ? evt.touches[0] : evt;
                pt.x = touch.clientX;
                pt.y = touch.clientY;
                return pt.matrixTransform(CTM.inverse());
            }
            
            function findPieceAt(pos) {
                // Check from last to first (top to bottom in z-order)
                // But prefer pieces where click is closer to center
                let bestPiece = null;
                let bestDist = Infinity;
                
                for (let i = pieces.length - 1; i >= 0; i--) {
                    const piece = pieces[i];
                    
                    // Skip preplaced pieces
                    if (piece.isPreplaced) continue;
                    
                    // Check if click is within any cell of the piece
                    for (const cell of piece.cells) {
                        const cellX = piece.x + cell.x;
                        const cellY = piece.y + cell.y;
                        const dist = Math.sqrt((pos.x - cellX) ** 2 + (pos.y - cellY) ** 2);
                        
                        if (dist < FICHA_RADIUS && dist < bestDist) {
                            bestDist = dist;
                            bestPiece = i;
                        }
                    }
                }
                return bestPiece;
            }
            
            function checkRotateIconClick(pos, piece) {
                // Find furthest cell (where rotation icon is)
                let furthestCell = piece.cells[0];
                let maxDist = 0;
                piece.cells.forEach(cell => {
                    const dist = Math.sqrt(cell.x * cell.x + cell.y * cell.y);
                    if (dist > maxDist) {
                        maxDist = dist;
                        furthestCell = cell;
                    }
                });
                
                const iconX = piece.x + furthestCell.x;
                const iconY = piece.y + furthestCell.y;
                const dist = Math.sqrt((pos.x - iconX) ** 2 + (pos.y - iconY) ** 2);
                
                return dist < 9; // 12px radius for icon click
            }
            
            let clickedMoveIndicator = false;
            
            function startDrag(evt) {
                const pos = getMousePos(evt);
                clickedMoveIndicator = false;
                
                // First, check all pieces for move indicator click (just selects the piece)
                const checkOrder = selectedPieceIndex !== null 
                    ? [selectedPieceIndex, ...pieces.map((_, i) => i).filter(i => i !== selectedPieceIndex)]
                    : pieces.map((_, i) => i).reverse();
                
                for (const idx of checkOrder) {
                    const piece = pieces[idx];
                    if (piece.isPreplaced) continue;  // Skip preplaced
                    if (checkRotateIconClick(pos, piece)) {
                        selectedPieceIndex = idx;
                        updateSelectionHighlight();
                        clickedMoveIndicator = true;
                        evt.preventDefault();
                        return;
                    }
                }
                
                // Normal drag behavior
                const pieceIdx = findPieceAt(pos);
                
                if (pieceIdx !== null) {
                    const piece = pieces[pieceIdx];
                    
                    selectedPieceIndex = pieceIdx;
                    updateSelectionHighlight();
                    
                    dragging = piece;
                    dragging.element.style.cursor = 'grabbing';
                    dragOffset.x = pos.x - dragging.x;
                    dragOffset.y = pos.y - dragging.y;
                    
                    // Hide grid when user starts playing
                    hideGridOnPlay();
                    
                    // Bring to front
                    const piecesGroup = document.getElementById('pieces-group');
                    piecesGroup.appendChild(dragging.element);
                    
                    // Clear snap when picking up
                    dragging.snappedTo = null;
                    
                    evt.preventDefault();
                }
            }
            
            function drag(evt) {
                if (!dragging) return;
                const pos = getMousePos(evt);
                dragging.x = pos.x - dragOffset.x;
                dragging.y = pos.y - dragOffset.y;
                dragging.element.setAttribute('transform', `translate(${dragging.x}, ${dragging.y})`);
                evt.preventDefault();
            }
            
            function endDrag(evt) {
                if (!dragging) return;
                dragging.element.style.cursor = 'grab';
                
                // Only try to snap if piece is in board area
                if (dragging.y < BOARD_BOTTOM) {
                    snapToBoard(dragging);
                }
                // Otherwise just leave it where it is (free movement)
                
                dragging = null;
            }
            
            svgEl.addEventListener('mousedown', startDrag);
            svgEl.addEventListener('mousemove', drag);
            svgEl.addEventListener('mouseup', endDrag);
            svgEl.addEventListener('mouseleave', endDrag);
            
            svgEl.addEventListener('touchstart', startDrag, { passive: false });
            svgEl.addEventListener('touchmove', drag, { passive: false });
            svgEl.addEventListener('touchend', endDrag);
        }
        
        function snapToBoard(piece) {
            // Try each board cell as potential anchor position
            let bestMatch = null;
            let bestDist = Infinity;
            
            for (const anchorId of Object.keys(boardCells)) {
                const anchorCell = boardCells[anchorId];
                
                // Distance from piece position to this potential anchor
                const anchorDist = Math.sqrt((piece.x - anchorCell.x) ** 2 + (piece.y - anchorCell.y) ** 2);
                
                // Skip if too far (optimization)
                if (anchorDist > FICHA_RADIUS * 2) continue;
                
                // Try to match all piece cells to board holes
                const matchedHoles = [];
                let allMatch = true;
                
                for (const pieceCell of piece.cells) {
                    // Calculate absolute position of this piece cell
                    const absPosX = anchorCell.x + pieceCell.x;
                    const absPosY = anchorCell.y + pieceCell.y;
                    
                    // Find matching board hole (by position only)
                    let foundHole = null;
                    
                    for (const holeId of Object.keys(boardCells)) {
                        const hole = boardCells[holeId];
                        const dist = Math.sqrt((absPosX - hole.x) ** 2 + (absPosY - hole.y) ** 2);
                        
                        if (dist > 8) continue; // Position doesn't match
                        
                        // Check not occupied by another piece
                        let occupied = false;
                        for (const other of pieces) {
                            if (other.id === piece.id || !other.snappedTo) continue;
                            if (other.snappedTo.includes(holeId)) {
                                occupied = true;
                                break;
                            }
                        }
                        
                        if (!occupied) {
                            foundHole = holeId;
                            break;
                        }
                    }
                    
                    if (foundHole !== null) {
                        matchedHoles.push(foundHole);
                    } else {
                        allMatch = false;
                        break;
                    }
                }
                
                // If all cells matched and this is closer than previous best
                if (allMatch && matchedHoles.length === piece.cells.length && anchorDist < bestDist) {
                    bestMatch = { anchorCell, matchedHoles };
                    bestDist = anchorDist;
                }
            }
            
            // Apply best match if found
            if (bestMatch) {
                piece.x = bestMatch.anchorCell.x;
                piece.y = bestMatch.anchorCell.y;
                piece.snappedTo = bestMatch.matchedHoles;
                piece.element.setAttribute('transform', `translate(${piece.x}, ${piece.y})`);
                
                // Deselect after successful placement
                selectedPieceIndex = null;
                updateSelectionHighlight();
                
                // Check for victory
                checkVictory();
            } else {
                // No valid position found - return piece to start position
                piece.x = piece.startX;
                piece.y = piece.startY;
                piece.snappedTo = null;
                piece.element.setAttribute('transform', `translate(${piece.x}, ${piece.y})`);
            }
        }
        
        window.rotatePiece = function() {
            if (selectedPieceIndex === null) return;
            const piece = pieces[selectedPieceIndex];
            piece.rotation = (piece.rotation + 72 * rotationDirection + 360) % 360;
            piece.snappedTo = null;
            rebuildPiece(piece);
        };
        
        window.toggleRotationDir = function() {
            rotationDirection *= -1;
            const btn = document.getElementById('rot-dir-btn');
            btn.textContent = rotationDirection === 1 ? 'â†» DERECHA' : 'â†º IZQUIERDA';
        };
        
        window.flipPiece = function() {
            if (selectedPieceIndex === null) return;
            const piece = pieces[selectedPieceIndex];
            piece.flippedV = !piece.flippedV;
            piece.snappedTo = null;
            rebuildPiece(piece);
        };
        
        window.flipPieceV = function() {
            if (selectedPieceIndex === null) return;
            const piece = pieces[selectedPieceIndex];
            piece.flippedH = !piece.flippedH;
            piece.snappedTo = null;
            rebuildPiece(piece);
        };
        
        window.deselectPiece = function() {
            selectedPieceIndex = null;
            updateSelectionHighlight();
        };
        
        // Current challenge tracking
        let currentChallenge = null;
        let currentCategory = null;
        let gridVisible = false;
        
        // Completed challenges tracking
        let completedChallenges = JSON.parse(localStorage.getItem('iqpentagon_completed') || '{}');
        let hintsUsed = 0;
        
        // Update all progress counters
        function updateAllProgress() {
            Object.keys(CATEGORIAS).forEach(cat => {
                const catData = CATEGORIAS[cat];
                let count = 0;
                for (let i = catData.start; i <= catData.end; i++) {
                    if (completedChallenges[i]) count++;
                }
                const progEl = document.getElementById('prog-' + cat);
                if (progEl) progEl.textContent = `${count}/24`;
            });
        }
        
        // Select a level and populate the grid (but don't necessarily show it)
        function populateGrid(category) {
            const grid = document.getElementById('challenge-grid');
            const cat = CATEGORIAS[category];
            grid.innerHTML = '';
            
            for (let i = cat.start; i <= cat.end; i++) {
                const btn = document.createElement('button');
                btn.className = 'btn';
                if (completedChallenges[i]) {
                    btn.classList.add('completed');
                }
                btn.textContent = i;
                btn.style.padding = '5px 0';
                btn.style.fontSize = '0.6rem';
                btn.style.minWidth = '36px';
                btn.onclick = () => {
                    loadChallenge(i);
                    // Grid stays visible - user can browse challenges
                    // It will auto-hide when user starts moving a piece
                };
                grid.appendChild(btn);
            }
        }
        
        // Hide grid when user starts playing
        function hideGridOnPlay() {
            if (gridVisible) {
                document.getElementById('challenge-grid-container').classList.add('hidden');
                document.getElementById('toggle-grid-btn').textContent = 'â–¼';
                gridVisible = false;
            }
        }
        
        // Select level - highlights it and populates grid
        window.selectLevel = function(category) {
            // Update selected level highlight
            document.querySelectorAll('#category-selector .btn').forEach(b => b.classList.remove('level-selected'));
            document.getElementById('btn-' + category).classList.add('level-selected');
            
            currentCategory = category;
            populateGrid(category);
            
            // Show grid
            const container = document.getElementById('challenge-grid-container');
            container.classList.remove('hidden');
            document.getElementById('toggle-grid-btn').textContent = 'â–²';
            gridVisible = true;
        };
        
        // Toggle grid visibility with â–¼/â–² button
        window.toggleGridVisibility = function() {
            const container = document.getElementById('challenge-grid-container');
            const btn = document.getElementById('toggle-grid-btn');
            
            if (gridVisible) {
                container.classList.add('hidden');
                btn.textContent = 'â–¼';
                gridVisible = false;
            } else {
                // If no category selected, select STARTER by default
                if (!currentCategory) {
                    currentCategory = 'STARTER';
                    document.getElementById('btn-STARTER').classList.add('level-selected');
                    populateGrid('STARTER');
                }
                container.classList.remove('hidden');
                btn.textContent = 'â–²';
                gridVisible = true;
            }
        };
        
        // Keep old function for compatibility
        window.toggleCategory = function(category) {
            selectLevel(category);
        };
        
        window.selectCategory = function(category) {
            selectLevel(category);
        };
        
        // Help functions
        window.showHelp = function() {
            document.getElementById('help-overlay').classList.remove('hidden');
        };
        
        window.hideHelp = function() {
            document.getElementById('help-overlay').classList.add('hidden');
        };
        
        window.loadChallenge = function(num) {
            // Exit intro mode and show pieces area
            if (introMode) {
                introMode = false;
                document.querySelector('rect[y="510"]').setAttribute('opacity', '1');
                document.querySelector('rect[y="515"]').setAttribute('opacity', '1');
                document.querySelector('text[y="535"]').setAttribute('opacity', '1');
            }
            
            currentChallenge = num;
            hintsUsed = 0;
            document.getElementById('game-info').textContent = `Reto ${num} - ðŸ’¡ Pistas: 0`;
            
            const inicio = INICIOS[num];
            const solution = SOLUCIONES[num];
            if (!solution) {
                alert('SoluciÃ³n no encontrada');
                return;
            }
            
            // Reset all pieces first - move to start positions with real colors
            const AREA_LEFT = 45, AREA_RIGHT = 505, AREA_TOP = 545, AREA_BOTTOM = 805;
            
            pieces.forEach(piece => {
                piece.x = piece.startX;
                piece.y = piece.startY;
                piece.rotation = 90;
                if (piece.type === 'A' || piece.type === 'B' || piece.type === 'G') {
                    piece.rotation = 270;
                }
                piece.flipped = false;
                piece.flippedV = false;
                piece.flippedH = false;
                piece.snappedTo = null;
                piece.isPreplaced = false;
                rebuildPiece(piece, false); // Use real colors
                
                // Clamp position to stay within bounds
                const clamped = clampPiecePosition(piece, AREA_LEFT, AREA_RIGHT, AREA_TOP, AREA_BOTTOM);
                piece.x = clamped.x;
                piece.y = clamped.y;
                piece.element.setAttribute('transform', `translate(${piece.x}, ${piece.y})`);
            });
            
            // Map piece types to piece indices
            const pieceMap = {
                'H': 0, 'H_2': 1,
                'D': 2, 'D_2': 3,
                'A': 4, 'A_2': 5,
                'B': 6, 'E': 7, 'F': 8, 'C': 9, 'G': 10
            };
            
            // Function to get cells for a piece configuration
            function getCellsForConfig(type, rotation, flipped, flippedV, flippedH) {
                let cells;
                switch(type) {
                    case 'H': cells = createPieceH_cells(rotation, flipped); break;
                    case 'D': cells = createPieceD_cells(rotation, flipped); break;
                    case 'A': cells = createPieceA_cells(rotation, flipped); break;
                    case 'B': cells = createPieceB_cells(rotation, flipped); break;
                    case 'E': cells = createPieceE_cells(rotation, flipped); break;
                    case 'C': cells = createPieceC_cells(rotation, flipped); break;
                    case 'G': cells = createPieceG_cells(rotation, flipped); break;
                    case 'F': cells = createPieceF_cells(rotation, flipped); break;
                    default: cells = [];
                }
                
                if (flippedV) {
                    cells = cells.map(cell => ({ x: cell.x, y: -cell.y, rotation: cell.rotation }));
                }
                if (flippedH) {
                    cells = cells.map(cell => ({ x: -cell.x, y: cell.y, rotation: cell.rotation }));
                }
                return cells;
            }
            
            // Function to find which board cells the piece covers when placed at position
            function findMatchingBoardCells(pieceCells, pieceX, pieceY) {
                const matched = [];
                for (const cell of pieceCells) {
                    const worldX = pieceX + cell.x;
                    const worldY = pieceY + cell.y;
                    
                    let closestId = null;
                    let closestDist = Infinity;
                    for (const [id, bc] of Object.entries(boardCells)) {
                        const dist = Math.sqrt((bc.x - worldX) ** 2 + (bc.y - worldY) ** 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestId = id;
                        }
                    }
                    if (closestDist < 5) {
                        matched.push(parseInt(closestId));
                    }
                }
                return matched.sort((a, b) => a - b);
            }
            
            // Place pieces from inicio (preplaced) 
            // The inicio tells us WHICH cells are pre-filled, but we need to match
            // them to the correct piece in the SOLUTION
            if (inicio) {
                // First, build a map of solution cells to solution keys
                const solutionCellsToKey = {};
                Object.keys(solution).forEach(solKey => {
                    const cells = solution[solKey].slice().sort((a,b) => a-b).join(',');
                    solutionCellsToKey[cells] = solKey;
                });
                
                Object.keys(inicio).forEach(inicioKey => {
                    const targetCells = inicio[inicioKey].slice().sort((a, b) => a - b);
                    const cellsStr = targetCells.join(',');
                    
                    // Find which solution key has these exact cells
                    const solKey = solutionCellsToKey[cellsStr];
                    if (!solKey) {
                        console.log('Could not find solution key for inicio', inicioKey, 'with cells', targetCells);
                        return;
                    }
                    
                    const pieceIdx = pieceMap[solKey];
                    if (pieceIdx === undefined) {
                        console.log('Unknown piece for solution key:', solKey);
                        return;
                    }
                    
                    const piece = pieces[pieceIdx];
                    const type = piece.type;
                    
                    const rotations = [90, 162, 234, 306, 18];
                    const flipOptions = [false, true];
                    
                    let found = false;
                    
                    for (const rotation of rotations) {
                        if (found) break;
                        for (const flipped of flipOptions) {
                            if (found) break;
                            for (const flippedV of flipOptions) {
                                if (found) break;
                                for (const flippedH of flipOptions) {
                                    if (found) break;
                                    
                                    const cells = getCellsForConfig(type, rotation, flipped, flippedV, flippedH);
                                    
                                    for (const anchorTargetCell of targetCells) {
                                        const boardCell = boardCells[anchorTargetCell];
                                        if (!boardCell) continue;
                                        
                                        const pieceX = boardCell.x - cells[0].x;
                                        const pieceY = boardCell.y - cells[0].y;
                                        
                                        const matched = findMatchingBoardCells(cells, pieceX, pieceY);
                                        
                                        if (matched.length === targetCells.length && 
                                            matched.every((v, i) => v === targetCells[i])) {
                                            piece.rotation = rotation;
                                            piece.flipped = flipped;
                                            piece.flippedV = flippedV;
                                            piece.flippedH = flippedH;
                                            piece.x = pieceX;
                                            piece.y = pieceY;
                                            piece.snappedTo = targetCells.map(String);
                                            piece.isPreplaced = true;
                                            found = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Rebuild all pieces
            pieces.forEach(p => rebuildPiece(p));
            selectedPieceIndex = null;
            updateSelectionHighlight();
        };
        
        // Game control functions
        window.rotatePiece = function() {
            if (selectedPieceIndex === null) return;
            const piece = pieces[selectedPieceIndex];
            if (piece.isPreplaced) return;
            piece.rotation = (piece.rotation + 72) % 360;
            piece.snappedTo = null;
            rebuildPiece(piece);
        };
        
        window.flipPieceH = function() {
            if (selectedPieceIndex === null) return;
            const piece = pieces[selectedPieceIndex];
            if (piece.isPreplaced) return;
            piece.flippedV = !piece.flippedV;
            piece.snappedTo = null;
            rebuildPiece(piece);
        };
        
        window.flipPieceV = function() {
            if (selectedPieceIndex === null) return;
            const piece = pieces[selectedPieceIndex];
            if (piece.isPreplaced) return;
            piece.flippedH = !piece.flippedH;
            piece.snappedTo = null;
            rebuildPiece(piece);
        };
        
        window.giveHint = function() {
            const solution = SOLUCIONES[currentChallenge];
            if (!solution) return;
            
            const pieceMap = {
                'H': 0, 'H_2': 1, 'D': 2, 'D_2': 3,
                'A': 4, 'A_2': 5, 'B': 6, 'E': 7, 'F': 8, 'C': 9, 'G': 10
            };
            
            function getCellsForConfig(type, rotation, flipped, flippedV, flippedH) {
                let cells;
                switch(type) {
                    case 'H': cells = createPieceH_cells(rotation, flipped); break;
                    case 'D': cells = createPieceD_cells(rotation, flipped); break;
                    case 'A': cells = createPieceA_cells(rotation, flipped); break;
                    case 'B': cells = createPieceB_cells(rotation, flipped); break;
                    case 'E': cells = createPieceE_cells(rotation, flipped); break;
                    case 'C': cells = createPieceC_cells(rotation, flipped); break;
                    case 'G': cells = createPieceG_cells(rotation, flipped); break;
                    case 'F': cells = createPieceF_cells(rotation, flipped); break;
                    default: cells = [];
                }
                if (flippedV) cells = cells.map(c => ({ x: c.x, y: -c.y, rotation: c.rotation }));
                if (flippedH) cells = cells.map(c => ({ x: -c.x, y: c.y, rotation: c.rotation }));
                return cells;
            }
            
            function findMatchingBoardCells(pieceCells, pieceX, pieceY) {
                const matched = [];
                for (const cell of pieceCells) {
                    const worldX = pieceX + cell.x, worldY = pieceY + cell.y;
                    let closestId = null, closestDist = Infinity;
                    for (const [id, bc] of Object.entries(boardCells)) {
                        const dist = Math.sqrt((bc.x - worldX) ** 2 + (bc.y - worldY) ** 2);
                        if (dist < closestDist) { closestDist = dist; closestId = id; }
                    }
                    if (closestDist < 5) matched.push(parseInt(closestId));
                }
                return matched.sort((a, b) => a - b);
            }
            
            // Get all currently occupied cells (excluding the piece we're about to move)
            function getOccupiedCells(excludePieceIdx) {
                const occupied = new Set();
                pieces.forEach((p, idx) => {
                    if (idx === excludePieceIdx) return;
                    if (p.snappedTo) {
                        p.snappedTo.forEach(c => occupied.add(parseInt(c, 10)));
                    }
                });
                return occupied;
            }
            
            for (const key of Object.keys(solution)) {
                const pieceIdx = pieceMap[key];
                if (pieceIdx === undefined) continue;
                const piece = pieces[pieceIdx];
                if (piece.isPreplaced) continue;
                
                const targetCells = solution[key].slice().sort((a, b) => a - b);
                const currentCells = piece.snappedTo ? piece.snappedTo.map(Number).sort((a, b) => a - b) : [];
                
                let isCorrect = currentCells.length === targetCells.length;
                if (isCorrect) {
                    for (let i = 0; i < targetCells.length; i++) {
                        if (targetCells[i] !== currentCells[i]) { isCorrect = false; break; }
                    }
                }
                
                if (!isCorrect) {
                    // Check if target cells are available (not occupied by other pieces)
                    const occupiedCells = getOccupiedCells(pieceIdx);
                    let canPlace = true;
                    for (const tc of targetCells) {
                        if (occupiedCells.has(tc)) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (!canPlace) {
                        // Skip this piece, try next one
                        continue;
                    }
                    
                    const rotations = [90, 162, 234, 306, 18];
                    const flipOptions = [false, true];
                    let found = false;
                    
                    for (const rotation of rotations) {
                        if (found) break;
                        for (const flipped of flipOptions) {
                            if (found) break;
                            for (const flippedV of flipOptions) {
                                if (found) break;
                                for (const flippedH of flipOptions) {
                                    if (found) break;
                                    const cells = getCellsForConfig(piece.type, rotation, flipped, flippedV, flippedH);
                                    for (const anchor of targetCells) {
                                        const bc = boardCells[anchor];
                                        if (!bc) continue;
                                        const px = bc.x - cells[0].x, py = bc.y - cells[0].y;
                                        const matched = findMatchingBoardCells(cells, px, py);
                                        if (matched.length === targetCells.length && matched.every((v, i) => v === targetCells[i])) {
                                            // Clear previous position first
                                            piece.snappedTo = null;
                                            
                                            piece.rotation = rotation;
                                            piece.flipped = flipped;
                                            piece.flippedV = flippedV;
                                            piece.flippedH = flippedH;
                                            piece.x = px;
                                            piece.y = py;
                                            piece.snappedTo = targetCells.map(String);
                                            rebuildPiece(piece);
                                            hintsUsed++;
                                            document.getElementById('game-info').textContent = `Reto ${currentChallenge} - ðŸ’¡ Pistas: ${hintsUsed}`;
                                            setTimeout(() => checkVictory(), 100);
                                            found = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (found) return;
                }
            }
        };
        
        window.resetPieces = function() {
            if (!currentChallenge) return;
            const inicio = INICIOS[currentChallenge];
            const AREA_LEFT = 45, AREA_RIGHT = 505, AREA_TOP = 545, AREA_BOTTOM = 805;
            
            pieces.forEach(piece => {
                // Skip preplaced pieces
                if (piece.isPreplaced) return;
                
                // Return to start position
                piece.x = piece.startX;
                piece.y = piece.startY;
                piece.rotation = 90;
                if (piece.type === 'A' || piece.type === 'B' || piece.type === 'G') {
                    piece.rotation = 270;
                }
                piece.flipped = false;
                piece.flippedV = false;
                piece.flippedH = false;
                piece.snappedTo = null;
                rebuildPiece(piece);
                
                // Clamp position to stay within bounds
                const clamped = clampPiecePosition(piece, AREA_LEFT, AREA_RIGHT, AREA_TOP, AREA_BOTTOM);
                piece.x = clamped.x;
                piece.y = clamped.y;
                piece.element.setAttribute('transform', `translate(${piece.x}, ${piece.y})`);
            });
            selectedPieceIndex = null;
            updateSelectionHighlight();
        };
        
        function launchConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8d8ea'];
            for (let i = 0; i < 80; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.top = '-10px';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    confetti.style.width = (Math.random() * 8 + 6) + 'px';
                    confetti.style.height = (Math.random() * 8 + 6) + 'px';
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
        }
        
        window.backToGrid = function() {
            document.getElementById('victory-overlay').classList.add('hidden');
            selectCategory(currentCategory);
        };
        
        window.nextChallenge = function() {
            document.getElementById('victory-overlay').classList.add('hidden');
            const cat = CATEGORIAS[currentCategory];
            if (currentChallenge < cat.end) {
                loadChallenge(currentChallenge + 1);
            } else {
                selectCategory(currentCategory);
            }
        };
        
        function checkVictory() {
            const solution = SOLUCIONES[currentChallenge];
            if (!solution) return;
            
            const pieceMap = {
                'H': 0, 'H_2': 1, 'D': 2, 'D_2': 3,
                'A': 4, 'A_2': 5, 'B': 6, 'E': 7, 'F': 8, 'C': 9, 'G': 10
            };
            
            let allCorrect = true;
            
            for (const key of Object.keys(solution)) {
                const pieceIdx = pieceMap[key];
                if (pieceIdx === undefined) continue;
                const piece = pieces[pieceIdx];
                
                const targetCells = solution[key].slice().sort((a, b) => a - b);
                const currentCells = piece.snappedTo 
                    ? piece.snappedTo.map(c => parseInt(c, 10)).sort((a, b) => a - b) 
                    : [];
                
                if (currentCells.length !== targetCells.length) {
                    allCorrect = false;
                    break;
                }
                
                for (let i = 0; i < targetCells.length; i++) {
                    if (targetCells[i] !== currentCells[i]) {
                        allCorrect = false;
                        break;
                    }
                }
                if (!allCorrect) break;
            }
            
            if (allCorrect) {
                completedChallenges[currentChallenge] = true;
                localStorage.setItem('iqpentagon_completed', JSON.stringify(completedChallenges));
                updateAllProgress();
                // Refresh grid if visible
                if (currentCategory) {
                    populateGrid(currentCategory);
                }
                launchConfetti();
                setTimeout(() => {
                    document.getElementById('victory-overlay').classList.remove('hidden');
                }, 500);
            }
        }
        
        function initInicios() {
            init();
            // Initialize progress counters
            updateAllProgress();
            // Play intro animation
            playIntro();
        }
        
        document.addEventListener('DOMContentLoaded', initInicios);
    })();
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered'))
                    .catch(err => console.log('SW registration failed:', err));
            });
        }
    </script>
</body>
</html>
